# 操作系统
## 内存管理
### 内存的基础知识
#### 什么是内存，有何作用
##### 存储单元，内存地址的概念和联系
#####  按字节编址和按字编址（对齐方式）
#### 程序运行的基本原理
##### 逻辑地址（程序猿可以操作的地址，也称为相对地址）VS物理地址（数据或者操作码在内存中的地址）
##### 从写程序到程序运行
###### 编辑源代码文件（由程序猿编写）(.c)
###### 编译
* 由源代码生成目标模块，此时为离散的模块，各自有逻辑地址，但是不完整(.o)
###### 链接
* 由目标模块生成装入模块，链接后形成完整的逻辑地址（.exe）
###### 装入
* 将装入模块装入内存，装入后形成物理地址
##### 三种链接方式
###### 静态链接
* 装入前形成一个完整的装入模块
###### 装入时动态链接
* 运行前边装入边链接
###### 运行时动态链接
* 运行时需要目标模块才装入并链接
##### 三种装入方式
###### 绝对装入
* 编译时产生绝对地址
* 单道程序阶段，无操作系统
###### 可重定位装入（静态重定位）
* 装入时将逻辑地址转换为物理地址
    * 编写程序时写入虚拟地址，地址变换在装入时一次完成（有相应的变换函数），所以称为静态重定位
    * 一个EXE装入内存时，要给他分配全部的内从空间
* 早期多道批处理阶段
###### 动态运行时装入（动态重定位）
* 运行时把逻辑地址转换为物理地址，需要设置一个重定位寄存器
    * 由于重定位寄存器的值可以修改，不像静态重定位那样固定，因此可以把程序分配到不连续的存储区中
    * 并且由于程序的局部性原理，可以只装入部分程序进入内存运行，因此可以或者一个比内存大多的多的逻辑地址空间
* 现代操作系统
### 内存管理的概念
#### 内存空间的分配与回收
##### 连续分配管理方式
###### 所有内存的分配都是以进程为单位连续分配
###### 单一连续分配（这里就我一个人）
* 只支持单道程序，内存分为系统区与用户区，用户程序存放在用户区
* 无外部碎片，有内部碎片
###### 固定分区分配（这里只有我能用，别人不能用）
* 支持多道程序，用户内存空间分为若干固定大小的分区，每个分区只能装一道作业
* 两种分区方式
    * 分区大小相等
    * 分区大小不等
###### 动态分区分配（哪里有空大家都能用，但是有些地方太小了大家都用不了）
* 支持多道程序，在进程装入内存时，根据进程的大小动态的建立分区
* 无内部碎片，有外部碎片
* 内部碎片可以采用紧凑的方法解决
* 回收内存分区时，可能遇到四种情况
    * 总之，相邻的分区要合并
    * 回收区后有相邻的 空闲分区
    * 回收区前有相邻的空闲分区
    * 回收区前后都有相应的空闲分区
    * 回收区前后都没有相应的空闲分区
* 动态分配分区算法
    * 实现动态分区的算法的数据结构
        * 空闲分区表或者空闲分区链
    * 首次适应算法
        * 算法思想
            * 从头到尾找到合适的分区
        * 分区排列顺序（数据结构）
            * 空闲分区以地址递增排序
        * 优点
            * 综合来看性能最好，算法开销小，回收分区后一般不需要对空闲分区重新排列
    * 最佳适应
        * 算法思想
            * 优先使用最小的分区，保留更大的分区
        * 分区排列顺序
            * 空闲分区以容量依次递增排序
        * 优点
            * 会有更多的大分区保留下来，更能满足大进程的需要
        * 缺点
            * 会产生太多很小的难以利用的碎片，算法开销大，是最垃圾的算法，会产生大量内部碎片
    * 最坏适应
        * 算法思想
            * 优先利用更大的空间，减少内部碎片的产生
        * 分区排列顺序
            * 与最佳适应一致
        * 优点
            * 减少碎片
        * 缺点
            * 空间很快就会被利用完毕，而且不适用于大进程
    * 邻近适应
        * 算法思想
            * 由首次适应演变而来，每次从上次查找结束的位置开始查找
        * 分区排列顺序
            * 空闲分区以地址递增次序排列
        * 优点
            * 不用每次都从低地址的小分区开始检索，算法开销小
        * 缺点
            * 会使高地址的分区产生碎片，而首次适应算法天然先分配小空间，这方面优于领近适应算法
##### 非连续分配管理方式
###### 允许一个程序分散的装入相邻的内存空间
###### 基本分页存储管理
* 基本分页存储管理的思想
    * 把进程分页，各个进程可以离散的放到各个内存块中
    * 基本分页存储实际上类似于分区很小的固定分区策略，因为块十分小所以一个程序占用内存的空间通常是离散的，也会产生极小的内部碎片，这种碎片叫做页内碎片
        * 与极小固定分区的本质区别在于其内存空间分配的不连续性
* 页表（数据结构）
    * 存放在内存中，如果找不到对应页会发生缺页中断，要访盘
    * 页表记录了页面和页框之间的一一对应关系
    * 一个进程对应一张页表，进程的每一页对应一个页表项，每个页表项由页号和块号组成
    * 每个页表项的大小是相同的，页号是隐含的
    * I号页表存放地址=页表开始地址+i*页表项大小
* 逻辑地址结构
    * 页号=逻辑地址/页面大小；页内偏移量=逻辑地址%页面大小
    * 页面大小一般为2的整数次幂，采用CAHCE分析即可
* 如何实现地址转换？
    * 计算出逻辑地址对应的「页号，页内偏移量」
    * 页号的合法性检查（与页表长度对比）
    * 若页号合法，再根据页表的起始地址，页号找到相对应的页表项（第一次访存）
    * 根据页笔项中记录的内存块号，页内偏移量找到最终的物理地址
    * 访问物理地址对应的数据（第二次访存）
* 具有快表的地址变换
    * 一种特殊的cache，将一小部分经常访问的页表项存储在TLB当中，在地址转换时优先访问快表
    * 若快表命中，则只需要一次访存即可
    * 若快表不命中，则访问主存中的页表，并根据对应的替换算法替换掉快表中的项
    * 主要功能就是类似于cah ce，加快地址变换，理论依据就是程序的时间局部性原理
    * TLB中只有页表项的副本，而普通cache中有各种数据的副本
* 多级页表
    * 逻辑地址结构
        * 「一级页号，二级页号，页内偏移量」
    * 几个细节
        * 多级页表中，各级页表的大小不能超过一个页面，若两级页表不够，可以分更多级
        * 多级页表的访存次数（假设没有快表），N级页表需要N+1次访存，这个机制类似于文件管理中的索引结构，不过索引结构是访盘，是IO，是DMA
* 分页管理的页面大小都是固定的，因此分页管理的地址是一维的
###### 基本分段存储管理
* 与分页管理不同，分段管理对用户不透明
* 优点
    * 方便编程，信息保护与共享，动态增长和动态链接
* 逻辑地址结构
    * 「段号S，段内偏移量」
* 段表
    * 「段号，段长，段内偏移量」
* 分段管理的段长由用户指定，因此分段管理的地址空间是二维的
###### 段页式存储管理
* 作业空间被划分为若干个逻辑段，再将每段划分成若干固定大小的页
* 逻辑地址
    * 「段号，页号，页内偏移量」，显然这个地址也是二维的
* 在一个进程中，段表只有一个，而页表可以有多个
* 地址变换过程
    * 先通过段表查询页表始地址（一次访存）
    * 通过页表找到页帧号（两次访存）
        * 如果这步命中TLB，则仅仅需要两次访存
    * 最后由页表中的地址找到数据（三次访存）
###### 段表和页表中由页号或者段号映射的结果最显著的区别就是段号直接给出首地址，物理地址由段+偏移量就可以得到，而页表中给出的页框号实际上表示的是前面有多少个页面，页框号*页面大小+偏移量才是真正的页面物理地址
#### 内存空间的扩充（虚拟内存）
##### 覆盖技术
###### 一个固定区
* 存放最活跃的程序段
* 固定区中的程序段在运行过程中不会调入调出
###### 若干覆盖区
* 不可能同时被访问的程序段可以共享一个覆盖区
* 覆盖区中的程序段在运行过程中会根据需要调入调出
###### 必须由程序猿声明覆盖结构，操作系统自动完成覆盖
###### 缺点：对用户不透明，增加了用户编程负担
##### 交换技术
###### 内存紧张时，换出某些进程用来腾出内存空间，再换入某些进程
###### 磁盘分为文件区和对换区，换出的进程放在对换区
##### 覆盖与交换的区别
###### 覆盖在同一个进程中进行的
###### 交换是在不同的作业中进行的
* 正在进行IO操作的进程不能被换出
* 正处于临界段的内存可以被换出
* 优先换出阻塞进程，优先换出优先级低的进程（中级调度）
    * 可以看出交换技术在目前仍有广泛应用
* PCB常驻内存，不会被换出
##### 虚拟内存技术
###### 传统存储管理方式的特征与缺点
* 一次性：作业必须一次性调入主存中
* 驻留性：作业数据在整个运行期间都常驻内存
###### 虚拟内存的特征与定义
* 局部性原理：程序不用整个都调入主存中，可以动态装入
* 特征
    * 多次性
    * 对换性
    * 虚拟性
###### 如何实现虚拟内存技术
* 访问的信息不在内存时，有OS负责从外存中调入内存（请求分页）
* 内存空间不够时，将暂时用不到的调出内存（页面置换）
* 虚存的大小需要同时满足两个条件
    * 虚存的大小要小于内存大小+外存大小
    * 虚存的大小小于OS所允许的最大地址位数能表示的容量，即不能超过地址空间的大小
* 虚拟内存的实现
    * 请求分页存储管理
        * 页表机制
            * 在基本分页的基础上增加了几个表项（在内存的页表中增加表项）
            * 状态位：表示页面是否已在内存中
            * 访问字段：记录最近被访问过几次，或记录上次访问的时间，供置换算法选择换出页面时参考（时钟算法）
            * 修改位：表示页面调入内存后是否被修改过，只有修改过的页面才需在置换时写回外存
            * 外存地址：页面在外存中存放的位置
        * 缺页中断机构
            * 找到页表后检查页表是否在内存中，若不在内存，产生缺页中断
            * 缺页中断处理后，需要将目标页面调入内存，有必要时还需要换出页面
            * 缺页中断属于内中断，属于内中断中的“故障”，即可能被OS修复的异常
            * 一条指令在执行过程中可能产生多次缺页中断
            * 综上，在缺页过程中OS可能进行的操作有
                * 保护现场
                * 磁盘IO
                * 修改页表
                * 页面替换
                * 分配内存（页框）
        * 地址变换机构（重点关注与基本分页不同的地方）
            * 找到页表项是需要检查页面是否在内存中
            *  若页面不在内存中，则需要请求调页
            * 若内存空间不足，还需要换出页面
                * 页面置换算法
                    * 最佳置换算法（opt）
                        * 优先淘汰最长时间不会被访问的页面
                        * 缺页率小，性能最好，但是无法实现，因为OS不能知道之后要使用哪个页面，或许可以通过大量数据集进行训练
                    * 先进先出置换算法（FIFO）
                        * 优先淘汰最先进入内存的页面
                        * 实现简单，但性能很差，可能出现Bleady异常
                    * 最近最久未使用置换算法（LRU）
                        * 优先淘汰最近最久没访问的页面
                        * 性能很好，但需要硬件支持，算法开销大
                    * 时钟置换（CLOCK）
                        * 循环扫描各个页面，第一轮淘汰访问位为0的，并将扫描过的页面访问位改为1，若第一轮没选中，则进行第二轮扫描
                        * 实现简单，仅需要添加一个访问位即可，但是未考虑页面是否被修改的问题，因为如果被修改替换页面需要写回外存，频繁替换这类页面会增大耗时
                    * 改进型的时钟置换
                        * 在时钟置换的基础之上添加一个修改位，即脏位，优先替换那些没被修改过的页面
                        * 淘汰优先级（未被访问，未被修改）>(未被访问，被修改)，若均为被访问过的页面，那么需要进行第二轮扫描
                        * 算法开销很小，性能也不错
            * 页面调入内存后，需要修改相应页表项
    * 请求分段存储管理
    * 请求段页式存储管理
#### 存储保护
##### 保证各进程在自己的 空间内运行，不会出现越界
##### 两种方式
###### 设置上下限寄存器
###### 利用重定位寄存器，界地址寄存器进行判断
* 基地址寄存器
    * 重定位寄存器也叫做基地址寄存器，其中的内容是面向OS的，用户不允许改变
    * 但是指令字中的形式地址A可以改变，运行到不同的形式地址时，可以是不同的进程，OS就会改变寄存器的值访问相应的内存单元，因此可以进行多道程序的沉浮和虚拟内存的扩展
* 相对应的由变地址寄存器
    * 地址也为（IX）+A
    * 寄存器中的内容可以由用户进行修改，一条指令制定一个基地址，用户编辑寄存器的值在这个基地址的基础上进行访存
        * 显然这种机制类似于数组的访问，因此变地址访存常用于数组的访问
#### 页面分配策略
##### 驻留集
###### 请求分页存储管理中给进程分配物理块的集合，在使用了虚拟存储技术的系统中，显然驻留集的大小要小于进程的总大小
* 如果分析一个页面需求为100的进程，若驻留集大小为100，那么显然除了第一次调入页面其余时候均不会发生缺页，而驻留集如果为1，那么就会频繁的发生缺页故障
* 缩小驻留集可以提高处理机的运行效率，但是会提高缺页的几率，而对于特定的进程，依据局部性原理，为其分配更多的主存空间对该进程的错误率不会有明显影响
##### 页面分配，置换策略
###### 固定分配局部置换
* 驻留集大小在运行之前就被定下来，不会再改变
* 显然固定分配策略不可能会有全局置换，因为全局置换需要把增加新的物理块到驻留集中，驻留集大小会发生改变
* 缺点
    * 灵活性差，分配不合理
###### 可变分配全局置换
* 在运行过程中如果发生缺页，OS会给进程分配一些未锁定的物理块，提高程序运行的灵活性
* 缺点
    * 会盲目给进程增加物理块，降低多道程序执行的并发度
###### 可变分配局部置换
* 刚开始给进程分配物理块，当进程发生缺页时，只允许在自己的驻留集中调入调出页面，如果发生频繁的缺页，则再由OS分配更多的物理块
* 优点
    * 分配物理块的策略更加合理，在保证不会发生过多的缺页故障的同时，也保证了多道程序设计的并发度
* 缺点
    * 需要更加复杂的实现，更大的开销，但对于频繁的缺页故障来说是值得的
###### 局部置换
* 发生缺页时只能选进程自己的物理块进行置换
###### 全局置换
* 可以将操作系统保留的空闲块或者其他进程暂时可以不用的物理块分配给缺页进程
###### 可变全局是只要缺页就给分配内存页可变局部是只有频繁缺页才给分配新的内存页
##### 调入页面的时机
###### 预调页
* 运行前调入
###### 请求调页
* 运行时调入内存，请求调页机制
##### 从何处调页
###### 系统拥有足够的对换区
* 对换区到主存
###### 系统缺少足够的对换区
* 不需要修改的从文件区到主存，需要修改则先调入对换区，在调入主存
###### UNIX方式
* 未经使用过的页面由文件区调入主存，而已经被用过但是被换出的放在对换区，之后也从对换区调入，显然这也是根据局部性原理设计的
###### 磁盘的对换区和文件区
* 对换区采用连续分配的方式，访问速度更快，文件区采用链接分配的方式，访问速度慢但空间利用率高
##### 抖动（颠簸）现象
###### 概念
* 刚换出的页面马上就要换入内出，刚换入的页面马上就要调出内存
###### 原因
* 某个进程频繁访问的页面数目高于可用的物理页面数目
##### 工作集
###### 为了解决抖动现象提出来的概念
* 在某段时间里，进程实际访问的页面的集合
* 注意与驻留集的区别，驻留集通常指的是请求分页管理中给进程分配的内存块的合集，而工作集是使用到的合集，通常来看工作集的大小要小于驻留集
* 产生页面抖动的主要原因是内存空间太小
## 进程管理
### 进程
#### 概念
##### 进程和程序的区别
###### 程序是静态的，是存放在磁盘里的可执行文件，就是一系列的指令合集
###### 进程是动态的，是程序的一次执行过程
###### 同一个程序运行在不同的数据集上可以对应多个进程
#### 组成
##### 一个进程由哪些部分组成
###### PCB（进程控制块）
* PCB是进程存在的唯一标志，创建时分配PCB，结束时回收PCB
* 进程描述信息
    * 进程标识符PID
        * 进程唯一的，不重复的身份证号
    * 用户标识符UID
        * 区分同一个OS的不同用户
* 进程控制和管理信息
    * CPU，磁盘，网络流量使用情况统计
    * 进程当前状态：就绪态/阻塞态/运行态
* 资源分配清单
    * 正在使用哪些文件
    * 正在使用哪些内存区域
    * 正在使用哪些IO设备
* 处理机相关信息
    * 如PSW，PC等各种寄存器的值（用于实现进程切换）
    * 堆栈指针
###### 程序段
* 程序代码（指令序列）
###### 数据段
* 运行过程中产生的各种数据（如程序中定义的变量）
###### 这里的组成更确切的说是进程实体的组成
#### 特征
##### 进程有哪些重要特征
###### 在没有线程系统的操作系统中，进程是资源分配和CPU调度的最小单位，在有线程系统的OS中，线程是资源分配的最小单位
###### 动态性
* 进程最基本的特性，是动态地产生，变化和消亡的
###### 并发性
* 内存中有多个进程实体，各进程可并发执行
###### 独立性
* 进程是独立运行，独立获得资源，独立接受调度的基本单位（注意这个基本单位，不是最小单位）
###### 异步性
* 各进程按各自独立的，不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步问题
###### 结构性
* 每一个进程都会配置一个PCB，结构上看，进程由程序段，数据段，PCB组成
##### 进程可能有的特征
###### 封闭性
*  进程的执行结果只取决于其本身，即使进程执行过程磕磕碰碰，受到外部环境的影响，对其执行结果也不会有影响
* 若进程失去封闭性，则并发进程共享变量，其执行结果与速度有关
#### 组织方式
##### 链接方式
###### 按照进程状态将PCB分为多个队列
###### 操作系统持有指向各个队列的指针
###### 队列直接链接PCB，查询速度较慢，需要依次便利前面的PCB
##### 索引方式
###### 根据进程状态的不同，建立几张索引表
###### 操作系统持有指向各个索引表的指针
###### 采用索引表将PCB名字存储起来，查询速度较快，用一定的内存空间存放索引表，是一种以空间换时间的策略
#### 状态与转换
##### 状态
###### 运行态
* 占有CPU
* CPU🈶️其他所需资源🈶️
###### 就绪态
* 具备运行条件，但是没有空闲CPU，而暂时不能运行
* CPU🈚️其他所需资源🈶️
###### 阻塞态
* 因等待某一时间而不能运行
* CPU🈚️其他所需资源🈚️
###### 创建态
* 分配资源，初始化PCB
###### 终止态
* 结束运行，回收资源，撤销PCB
##### 状态间的转换
###### 就绪态-》运行态
* 处理机调度
###### 运行态-》就绪态
* 时间片时间到
###### 运行态-》阻塞态
* 时间等待，等待IO
###### 阻塞态-》就绪态
* 事件发生，即IO设备可用
###### 创建态-》就绪态
* 系统完成创建进程相关的工作
###### 运行态-》终止态
* 进程运行结束，或运行过程中遇到不可修复的错误
##### 进程的组织方式（PCB的组织方式）
###### 在pCB中会给出一个变量来表示STATE，用于pCB之间的组织，方便进程之间的调度
#### 进程的控制
##### 基本概念
###### 什么是进程控制
* 进程控制就是要实现进程状态之间的转换
###### 如何实现进程控制
* 进程控制由原语实现
    * 原语用开中断关中断来实现
    * 原语是一种特殊的程序（对应多个微程序）
    * 不可被打断
##### 进程控制相关的原语
###### 创建
* 创建原语
    * 申请空白PCB（PCB数目有限，可能申请失败）
    * 为进程分配所需资源
    * 初始化PCB
    * 将PCB插入就绪队列
* 创建时CPU需要做什么
    * 填写一个该进程的进程表项
    * 分配该进程适当的内存
    * 将该进程插入就绪队列
        * 就绪队列
        * 就绪索引队列
* 引起进程创建的事件
    * 用户登录
    * 作业调度
    * 提供服务
    * 应用请求
###### 终止
* 撤销原语
    * 从PCB集合中找到欲终止的PCB
    * 若程序正在运行，立即剥夺CPU
    * 终止所有子进程
    * 将该进程所有的资源归还给父进程或者OS
        * 整个进程被撤销归还给OS
        * 子进程被撤销归还给父进程
    * 删除PCB
* 引起终止的时间
    * 正常结束（进程自己请求终止）
    * 异常结束（整数除0，非法使用特权指令）
    * 外界干预（用户选择结束进程，任务管理器）
###### 阻塞
* 阻塞原语（运行态-》阻塞态）
    * 找到要阻塞的进程对应的PCB
    * 保护现场（即保护进程所对应的寄存器中的值，通过堆栈放入主存中），将其PCB设置为阻塞态，暂时停止其运行
    * 将PCB插入响应事件的等待队列
* 引起阻塞的事件
    * 需要等待系统分配某种资源
        * 申请临界资源
        * 申请从磁盘中读数据
        * 申请打印机工作
    * 需要等待相互合作的其他进程完成工作
###### 唤醒
* 唤醒原语（阻塞态-》就绪态）
    * 在事件等待队列中找到PCB
    * 将PCB从等待队列中移除，设置进程为就绪态
    * 将PCB插入就绪队列，等待被调度
* 引起唤醒的事件
    * 等待时间的发生
        * IO结束
        * 某进程退出临界区
###### 切换
* 切换原语
    * 运行态-》就绪态  就绪态-〉运行态
    * 将运行环境信息存入PCB
    * 选择另一个进程执行，并更新其PCB
    * 根据PCB恢复新进程所需运行环境
* 引起进程切换的事件
    * 当前进程时间片到
    * 有更高优先级的进程到达
    * 当前进程主动阻塞
    * 当前进程终止
* 注意切换与调度的区别
    * 切换
        * 执行行为，实际分配的行为
    * 调度
        * 决策行为，决定分配资源给哪个进程
#### 进程通信
##### 为什么要有进程通信
###### 进程是分配系统资源的单位，各个进程拥有独立的地址空间
###### 为了保证安全，一个进程不能直接访问另一个进程
##### 共享存储
###### 设置一个贡献空间用于资源共享
###### 基于数据结构的共享（低级）
* 共享空间为一个10位的数组或者结构体之类的
###### 基于存储区的共享（高级）
* 直接画出一个存储区，是高级通信方式
##### 消息传递
###### 传递结构化的消息（消息头/消息体）
* 类似于计网中的封装
###### 系统提供’发送接收原语’
###### 两种方式
* 直接通信
    * 消息直接挂到接收方的消息队列里
* 间接通信
    * 消息先发到中间体
##### 管道通信
###### 设置一个缓冲区进行通信（与磁盘和CPU信息交换的缓冲区类似）
###### 一个管道只能实现半双工通信
###### 写满时，不能再写，读空时，不能再读（由pV操作进行控制）
* 可以看出进程对管道的读操作和写操作都有可能被阻塞
* 管道空时的读操作和管道满时的写操作
###### 没写满，不能读，每读空，不能写（与CPU和磁盘的信息交换也类似）
###### 管道的数据一旦读出会立即消失
* 只能有一个读进程
* 可以有多个写进程
##### 高级通信方式，PV操作属于低级通信方式，高级通信效率高，数据大
### 线程
#### 什么是线程，为什么要引入线程
##### QQ，微信是不同进程，为了实现在不同进程中子功能，视频，打字等
##### 通过引入新城来增加程序运行的并发度
#### 引入线程机制后，有哪些变化
##### 资源调度分配
###### 程序的最小执行单位变成了线程，即CPU最小执行单位变成了线程，但是资源分配的最小单位还是进程，线程天然拥有进程的资源
* 这种资源包括页表
* 线程切换不会引起页表始地址的改变
##### 并发行
##### 系统开销
###### 线程之间切换，系统开销较小
###### 进程之间切换，系统开销较大
###### 引入线程机制可以提高系统的并发度
#### 线程有哪些重要的属性
##### 处理机调度的单位
##### 多CPU计算机中，各个线程可以使用不同的CPU（多核心CPU也可）
##### 每个线程都有一个线程ID，线程控制块（TCB）
##### 线程几乎不拥有系统资源（天然共享进程）
###### 对于不同进程中使用同一字母表示的变量互不共享内存空间，因此不用考虑互斥
###### 对于同一进程的不同线程可共享进程定义的全局变量，可以自己定义局部变量，局部变量之间不共享，全局变量可共享
###### 进程的全局进程需要考虑互斥访问，进程间的局部变量则不用考虑
##### 不同线程的进程切换会引起进程切换
###### 开销大
#### 线程的实现方式
##### 用户级线程
###### 类似于自己封装一个代码库，采用控制语句进行线程的实现（用于只支持进程不支持线程的系统）
###### 线程的管理工作由应用程序控制完成，包括线程之间的切换
###### 线程切换在用户态下即可完成，不需要进入管态
###### 系统内核意识不到用户级线程的存在，只有用户视角可以看到这些线程
###### 优缺点
* 开销小，效率高
* 一个用户级线程被阻塞，所有进程都会被阻塞，并发度低，多个线程不可在多核处理机上并发运行
    * 因为实际上就是占用了一个进程，通过应用程序判断线程使用，此时CPU调度的基本单位是进程，因此其中一个线程阻塞就是进程被阻塞，CPU无法调度其他的线程，并发度低
##### 内核级线程
###### 在内核层面设置的线程（OS支持）
###### 管理工作由操作系统内核完成
###### 线程调度，切换工作都由内核负责，内核极线程的切换必须在管态下完成
###### 操作系统能察觉到内核级线程的存在，有TCB（线程控制块），只有内核级线程才是处理机调度的基本单位
###### 优缺点
* 一个线程被阻塞，别的线程还能继续执行，并发能力强
* 多个内核级线程的切换由OS完成，需要切换到管态，成本高，开销大
    * 因为OS支持了线程，因此此时的线程是CPU调度的最小单位，一条线程被阻塞不会导致其他线程被阻塞
#### 多线程模型
##### 多对一模型
###### 多个用户级线程映射到一个内核级线程（只有一个CPU调度的基本单位）（对应用户级线程）
###### 线程管理开销小，效率高
###### 一个线程阻塞会导致整个进程都被阻塞
##### 一对一模型
###### 一个用户级线程映射到一个内核级线程
###### 各个线程都可以分配到多核处理机并发执行，并发度高
###### 线程管理都需要OS的支持，开销大
##### 多对多模型
###### N个用户级线程映射到m个内核级线程（N≥m）
###### 集二者所唱
### 处理机调度
#### 调度的概念
##### 基本概念
###### 为就绪队列的进程合理分配软硬件资源，提高多道程序系统的运行效率
##### 三个层次
###### 高级调度（作业调度）
* 按照调度算法，从后备队列中选择进程调入内存，并为其创建进程
* 辅存与主存之间的调度（面向作业）
###### 中级调度（内存调度）
* 按照某种规则，从挂起队列中选择合适的进程将其数据调回内存
* 内存分配中的交换
* 发生在辅存和主存之间（面向进程）
###### 低级调度（进程调度）
* 从就绪队列中选择一个进程为其分配处理机
* 主存与CPU之间的数据交换
##### 注意点
###### 为减轻系统负担，提高资源利用率，暂时不执行的进程会被调到外存而变成挂起态
###### 七状态模型：在五状态模型的基础上加入了“就绪挂起”和“阻塞挂起”两种状态
#### 调度算法的评价指标
##### CPU利用率
###### 忙碌的事件/总事件
##### 系统吞吐量
###### 完成了多少道作业/花费了多少时间
##### 周转时间
###### 周转时间=作业完成时间-作业提交时间
###### 平均周转时间=各作业周转时间之和/作业数
###### 带权周转时间=作业周转时间/作业实际运行的时间
###### 平均带权周转时间=各作业带权周转时间之和/作业数
##### 等待时间
###### 作业/进程 等待被服务的时间之和
###### 平均等待时间 即各个进程/作业 等待时间的平均值
##### 响应时间
###### 从用户提交请求到首次产生响应所用的时间
#### 六大处理机调度算法
##### 两者都不适合
###### FCFS（先来先服务）
* 算法思想
    * 公平
* 规则
    * 先后顺序
* 用于何处
    * 作业调度
        * 作业先到达后备队列
    * 进程调度
        * 进程先到达就绪队列
* 是否可抢占
    * 不可抢占
* 优缺点
    * 算法简单，对长作业友好有利于CPU繁忙型作业，而不利于IO繁忙型作业
        * 从处理机下来进行IO的进程在进入处理机会进入就绪队列的队尾
        * CPU繁忙型作业一旦持有CPU就会长时间运行，不会有频繁的IO操作，很快就能执行完
        * 因为如果有频繁的IO操作，刚上处理机就要下来，再重新调入CPU需要在就绪队列的最后面，执行效率低
    * 对短作业不利。效率低
* 饥饿
    * 不会
###### SJB（短作业优先）
* 算法思想
    * 追求最短的
        * 平均等待时间
        * 平均周转时间
        * 平均带权周转时间
* 规则
    * 最短的作业优先得到服务
* 用于何处
    * 作业进程皆可
* 是否可抢占
    * 非抢占式
* 优缺点
    * 最短的等待时间和周转时间
    * 不公平，对短作业有利，对长作业不利，会产生饥饿现象
* 饥饿
    * 长作业会饥饿
##### 适用于实时OS系统
###### 优先级调度
* 算法思想
    * 根据紧急情况对待处理任务进行排序，适用于时响应要求高的场景
* 规则
    * 每个作业和进程都有各自的优先级，调度时选择优先级最高的作业或者进程，
        * 静态优先级
            * 整个运行期间不再改变
        * 动态优先级
        * IO作业优先级高于CPU作业
            * 因为IO没办法长时间保存输入输出数据
* 用于何处
    * 作业，进程，IO
* 是否可抢占
    * 抢占式非抢占式都有
        * 抢占式
            * 不重要的在处理机上直接暂停他，放入优先级更高的
        * 非抢占式
            * 让处理机上的先运行完
* 优缺点
    * 可区分轻重缓急，灵活的调整进程的优先级
    * 若不断有优先级更高的进程进入就绪队列，会导致进程饥饿
* 饥饿
    * 会
##### 适用于分时操作系用
###### 高相应比优先
* 算法思想
    * 综合考虑作业/进程的等待时间和要求服务的时间
    * 响应比=（等待时间+要求服务时间）/要求服务时间
* 规则
    * 根据响应比分配优先级，响应比最高的作业优先投入运行
* 用于何处
    * 作业/进程
* 是否可抢占
    * 不可抢占
* 优缺点
    * 综合考虑短作业优先和先来先服务，加上一个等待时间作为排序因子，时间耗费长的任务等待时间长了优先级也会提高
* 饥饿
    * 不会导致饥饿
###### 时间片轮转
* 算法思想
    * 公平的提供时间片
* 规则
    * 按照各个进程达到就绪队列的顺序，轮流让各个进程执行一个时间片，无论是否执行完，都下处理机
* 用于何处
    * 进程/作业
* 是否可抢占
    * 可抢占
* 优缺点
    * 公平，响应快，适用于分时操作系统
    * 由于高频率的进程切换，会有一定的开销，而且没有优先级任务排序，不适用于相应要求高的系统
* 饥饿
    * 不会
* 时间片太大
    * 小进程浪费过多时间片，甚至走不完一个时间片
* 时间片太小
    * 频繁的进程切换增加系统负担
###### 多级反馈队列
* 算法思想
    * 对其他调度算法的折中
* 规则
    * 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大，这个时间片就是这个队列中的进程可以使用的时间片长度
    * 若在第一优先级队列还没运行完进程需要的处理机时间，则被调入下级优先队列，直到更高优先级的队列中为空时，才会运行低优先级队列中的进程
        * 若在低优先级队列运行过程中，有任务进入高优先级队列，则立即暂停此时的CPU上的任务，让高优先级的任务进入CPU运行，被替换下来的任务不进入低优先级队列，而是回到原队列，按照优先级继续判断是否运行
    * 最低级队列数目由OS制定，当进程到最低级优先队列时间片轮转时间到不会再进入下级队列，而是重新回到队尾
* 用于何处
    * 进程调度
* 是否可抢占
    * 可抢占
* 优缺点
    * 优点
        * 终端型作业用户
            * 短作业优先
        * 短批处理作业用户
            * 周转时间较短
        * 长批处理作业用户
            * 经过前面几个队列得到部分执行，不会被饿死
* 饥饿
    * 不会
        * 子主题 1
#### 同步和互斥
##### 同步和互斥的概念
###### 异步性：加法进程发生在减法进程之前，即不按照预先的约定指令执行顺序执行进程
###### 由于进程的并发执行带来了异步性，而我们为了维持同步性需要采取一些手段，同步性是什么？
* 同步也称为直接制约关系，是指为完成某种任务而建立的两个或多个进程
###### 互斥
* 互斥也叫间接制约关系，当一个进程进入临界区（打印机）使用资源时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一进程才被允许访问该资源
##### 进程互斥
###### 对临界资源的访问需要互斥的进行，即同一时间只能允许一个进程访问该资源
* 常见临界资源（互斥共享资源）
    * 打印机
    * 共享变量
    * 缓冲区
* 常见用于干扰的非临界资源
    * 非共享数据区 （破坏共享）
    * 可重入的代码（破坏互斥）
    * 磁盘存储介质（破坏互斥）
###### 四个部分
* 进入区
    * 检查是否可进入临界区，若可进入，需要上锁
* 临界区
    * 访问临界资源的那部分代码
* 退出区
    * 负责“解锁”
* 剩余区
    * 其余代码部分
###### 需要遵循的原则
* 空闲让进
    * 临界区空闲时，应允许一个进程访问
* 忙则等待
    * 临界区正在被访问时，其他试图访问的进程需要等待
* 有限等待
    * 要在有限的时间进入临界区，保证不会饥饿
* 让权等待
    * 进不了临界区的进程，要释放处理机，防止忙等
###### 软件实现方法
* 单标志法
    * 在进入区只做检查，不上锁
    * 在退出区把临界区的使用权转交给另一个进程
    * 主要问题：不遵循“空闲让进”的原则
    * 只能循环交替进入临界区
* 双标志先检查
    * 在进入区先检查后上锁，退出区解锁
    * 主要问题：不遵循忙则等待的原则
    * 可能两个互斥进程同时访问临界区，出现这种问题的原因是因为同步机制没有做好
* 双标志后检查
    * 在进入区先“加锁后检查”，退出区解锁
    * 不遵循空闲让进，有限等待的原则，可能会导致饥饿
    * 在检查对方是否在占用临界资源之前就把标志为修改了，若双方同时进行这个操作，则两个进程全都无法访问临界资源
* peterson算法（三标志）
    * 在进入区“主动争取-主动谦让-检查对方是否想进，己方是否谦让”
        * 访问临界资源前先声明自己欲访问这个资源，进入临界区之前的检查同时检查（flag【j】（对方的访问状况&&turn（自己的访问状态）））
    * 主要问题：不遵循“让权等待”原则，会发生忙等
* 只有运行态和就绪态，如果无法访问临界资源就会一直在处理机上，处于忙等状态
###### 硬件实现方法
* 中断屏蔽方法
    * 通过开关中断指令实现
    * 优点：简单高效
    * 缺点：只适用于单处理机，只适用于操作系统内核进程
* TESTANDSET指令
    * 实现过程
        * OLD记录是否已被上锁
        * 再将LOCK设置为TRUE
        * 检查临界区是否已被上锁
        * 若已上锁，则循环重复前几步
    * 优点
        * 实现简单，适用于多处理机环境
    * 缺点
        * 不满足“让权等待”
        * 不可以在关中断条件下运行这个指令，因此如果临界区资源一直被加锁，该进程也无法被中断，会导致 系统宕机
* swap指令
    * 逻辑上同TSL
* 只有运行态和就绪态，如果无法访问临界资源就会一直在处理机上，处于忙等状态
##### 信号量机制
###### 整型信号量
* 用一个整数型变量作为信号量，数值表示某种资源数
* 整型信号量与普通整型变量的区别：对信号量只能进行初始化，PV三种操作
* 整型信号量存在的问题：不满足让权等待的原则
###### 记录型信号量（OS最最高频出题点）
* S.value表示某种资源数，S.L指向等待该资源的队列
* P操作中，一定是S.valu- -，若自减后value<0，说明原来就为0，表示没有可用资源，将该进程挂起
* V操作中，一定是S.value++，若自增后value≤0，说明之前在P操作的事后有进程被阻塞，此时需要通过执行wakeup原语唤醒队首进程P，
* 可以用记录型信号量实现系统资源的申请和释放
* 可以用记录型信号量实现进程互斥和同步
###### 通过记录型信号量实现互斥同步和前驱
* 实现进程互斥
    * 分析问题，确定临界区
    * 设置互斥信号量，初值为1
    * 临界区之前对信号量执行P操作
    * 临界区之后对信号量执行V操作
    * P（mutex）「访问临界资源」V（mutex）
    * 这里的临界段长度尽量小，只包含互斥资源，不然极容易引起死锁
* 实现进程同步
    * 分析问题，找出哪里需要实现一前一后的同步关系
    * 设置同步信号量，初始值为0
    * 在“前操作”之后执行V操作
    * 在“后操作”之前执行P操作
    * 只有前操作释放互斥资源MUTEX，只能释放资源给后继操作
* 实现进程的前驱关系
    * 不难看出，前驱的本质就是多级同步问题，只有在所有钱前驱活动都结束才能进行后继操作
    * 分析问题，画出前驱图（AOE网？）
    * 为每一对前驱关系设置同步信号量，初值 为0
    * 在每个“前操作”之后执行V操作
    * 在每个“后操作”之前执行P操作
###### 管程
* 为什么要引入管程
    * 解决信号量机制编程麻烦，易出错的问题
    * 类似于封装整个过程，class
* 组成
    * 共享数据结构
    * 对数据结构初始化的语句
    * 一组用来访问数据结构的过程
    * 管程的名称
* 基本特征
    * 各外部进程/线程只能通过管程提供的特定入口才能访问共享数据
    * 每次仅允许一个进程在管程内执行某个内部过程
* 补充
    * 各进程必须互斥访问管程的特性是由编译器实现的
        * 与wait/signal操作没有关系
    * 可在管程中设置条件变量及等待/唤醒操作以解决同步问题
    * 管程既可以实现同步问题，可以实现互斥问题
* 与PV操作的比较
    * 相似点
        * 条件变量的wait/signal操作类似于信号量的PV操作，可以实现进程的阻塞和唤醒
    * 不同点
        * 条件变量是没有值的，仅仅实现了排队的功能，而信号量机制会定义互斥信号量记录资源数目
###### 几大经典同步互斥算法
* 主要掌握生产者消费者问题和读者写者问题
#### 死锁
##### 死锁的概念
###### 什么是死锁
* 各进程互相等待对方手里的资源，导致各个进程都阻塞，无法向前推进
###### 死锁，饥饿，死循环的区别
* 死锁：至少是两个进程一起死锁，且都会处于阻塞态
* 饥饿：只可以只有一个饥饿进程，饥饿进程可能阻塞也可能就绪
* 死循环：可能只有一个进程发生死循环，死循环的进程可上处理机
* 死锁和饥饿是OS互斥和调度时要解决的问题，死循环是程序员要解决的问题
###### 死锁产生的四个必要条件
* 互斥条件
    * 只有对互斥资源的争抢才会导致死锁，对共享资源的争抢永远不会死锁，SPOOLING技术
* 不剥夺条件
    * 进程保持的资源只能主动释放，不可强行剥夺
* 请求和保持条件
    * 保持着某些资源不放的同时，请求别的资源
* 循环等待条件
    * 存在一种进程资源的循环等待链
    * 循环等待未必死锁，死锁一定循环等待
        * 即允许资源强行剥夺或者其他两个死锁的条件被破坏后均可打破死锁的状态
###### 什么时候会发生死锁
* 对不可剥夺的临界资源的不合理分配会导致死锁
###### 死锁的处理策略
* 不允许死锁的发生
    * 静态策略：预防死锁
        * 破坏死锁的四个必要条件
            * 互斥
                * 将临界资源改造成为可共享使用的资源（spooling技术）
                * 缺点：可行性不高，很多时候无法破坏互斥条件
            * 不剥夺
                * 方案一，申请的资源得不到满足时，立即释放拥有的所有资源
                * 方案二，申请的资源被其他进程占用时，由操作系统协助剥夺（考虑优先级）
                * 缺点：实现复杂，剥夺资源可能导致部分工作实效，反复申请和释放导致系统开销大，可能导致饥饿
            * 请求和保持
                * 运行前分配好所有需要的资源，之后一直保持
                * 缺点：资源利用率低，可能导致饥饿
            * 循环等待
                * 给资源编号，必须按照编号顺序申请资源
                * 缺点：不方便增加新设备，会导致资源浪费，给用户变成带来麻烦
    * 动态策略：避免死锁
        * 避免系统进入不安全状态（银行家算法）
            * 不安全状态有可能进入死锁状态
            * 安全状态一定不会进入死锁状态
            * 死锁状态一定是 不安全状态
* 允许死锁发生
    * 死锁的检测和解除
        * 
            * 如何检测
                * 数据结构：资源分配图
                    * 两种结点
                        * 进程结点
                        * 资源结点
                    * 两种边
                        * 进程结点-》资源结点（请求边）
                        * 请求边表示进程还需要多少个资源
                        * 资源结点-》进程结点（分配边）
                        * 分配边表示OS已经给了多少个资源
                    * 环路与死锁
                        * 出现环路不一定死锁
                        * 不出现环路一定不会死锁
                            * 没有循环等待
                        * 每种资源只有一个，并出现环路一定死锁
                * 死锁检测算法
                    * 依次消除与不阻塞进程相连的边，直到无边可消
                    * 注：所谓不阻塞进程是指其申请的资源数还足够的进程
                    * 死锁定理：若资源分配图不是可完全简化的，说明发生了死锁
            * 如何解除
                * 资源剥夺法
                * 撤销进程法（终止进程法）
                * 进程回退法
            * 如何决定对谁撤销
                * 进程优先级
                * 已执行多长时间
                * 还有多久完成
                * 进程已经使用了多少资源
                * 进程是交互式的还是批处理式的
* 死锁与资源数的关系
    * N个并发进程都需要M个同类资源，则该系统必然不会发生死锁的自少资源为（M-1）*N+1
* 死锁检测，死锁避免，死锁预防的一些对比
    * 死锁避免需要进程运行所需的总量信息，而i死锁检测不需要
    * 死锁避免不会给可能导致死锁的进程分配资源，而死锁检测需要
    * 死锁预防会限制用户申请资源的顺序，而死锁检测不会
    * 就并发度来看，死锁检测>死锁预防>死锁避免
## IO管理
### IO概述
#### IO设备分类
##### 使用特性
###### 人机交互类外部设备
* 鼠标键盘
* 显示器
###### 存储设备（外存）
* 磁盘，光盘
###### 网络通信设备
* 网络接口
* 调制解调器
##### 传输速率
###### 低速
* 鼠标键盘
    * 中断方式
###### 中速
* 打印机
    * 中断
###### 高速
* 磁盘
    * DMA
##### 信息交换
###### 块设备
* 通常几个字节，或者几百个字节作为一个块。
* 传输速率较快，以块为单位进行数据传输
* 可寻址，可以随机读写任意一个块
###### 字符设备
* 以一个字符为单位，属于无结构类型
* 传输速度速率低，不可寻址
* 常用于打印机等设备，采用中断方式
#### IO控制方式
##### 程序直接控制（轮询访问）
###### 数据传输准备和数据传输阶段CPU与iO设备均串行，效率极低。传输以字为单位，字的大小可以根据数据寄存器的宽度得到
##### 中断控制
###### 数据传输准备阶段并行，数据传输阶段串行
###### iO设备准备好了向CPU发出中断请求，这个中断为一个外中断信号
###### 每中断一次传输一个字，数据传输在CPU处于中断处理程序的那段时间进行
###### 中断是由CPU和OS一起完成的，其中保护断点（pc psw）由CPU完成，保存现场由OS完成
* 断点为PC和pSW中的内容
* 现场为其他寄存器组中，在中断过程中数据可能会被覆盖，通过采用堆栈保护现场，把寄存器中的值先压入堆栈，然后存到主存中，来完成保护现场
###### 只能发生在指令周期中的执行周期之后
##### DMA方式
###### 数据传输和准备阶段都与Cpu并行
###### 直接构建与CPU之间的数据通路（并非物理通路）
###### 基本单位时数据块，通常为一个内存页大小（4KB）
###### 除了开始和结束时需要CPU参与，其余阶段均不需要CPU参与
###### 可以发生在任何一个机器周期之后
##### 通道控制
###### 是对DMA方式的发展
* DMA方式由CPU来控制传输的数据块大小，通道方式则由通道完成
* 每个DMA控制器对应一个iO设备与内存交换数据，而一个通道可以控制一组设备
###### 可以看作多个DMA并发传输数据，原来CPU干预的为一个数据块的读写，在引入通道机制后改为对一组数据块的读写
###### CPU向IO通道发送IO指令，来控制iO设备
* 可以看出采用通道的计算机都是采用独立编址的方式，有自己的一整套IO地址
* 通道指令的类型单一，没有自己的内存，其通道程序放在主存中，有自己独立的地址空间
###### 通道是一个硬件实体
#### IO层次结构
##### 用户层软件
###### 库函数的调用
###### 实现与用户交互的接口，向上提供方便易用的库函数
##### 设备独立性软件（设备无关层）
###### 向用户层软件提供调用接口
###### 对设备的保护（访问权限）
###### 差错处理
###### 设备的分配与回收
* 设备分配时需要注意的内容
    * 设备的固有属性
    * 设备独立性
    * IO处理机
* 对设备的统一编号称为绝对号
###### 将参数翻译成设备操作命令
###### 根据用户层给的命令不同，调用相应的设备驱动程序
##### 设备驱动程序
###### 设置设备寄存器，检查设备状态
###### 通常一类设备采用一个驱动程序，比如2台显示器和3台打印机，通常在系统中存有两个驱动程序
##### 中断处理程序
###### 进行中断处理
* 外中断
* 内中断
##### 硬件
###### 主要有IO控制器（IO接口），执行具体的IO操作
* IO接口由若干IO端口组成，所谓IO端口即各种各样的IO寄存器
### IO核心子系统
#### IO调度
##### 定义
###### 确定一个好的顺序来执行OS中的IO请求，类似于IO调度算法
##### 作用
###### 改善系统性能
###### 使进程公平的共享设备访问
###### 减少IO完成所需等待时间
##### 实例
###### 磁盘调度算法
#### 高速缓存与缓冲
##### 分类
###### 高速缓存
* 实现方式 
    * 利用主存中的一片存储空间用作经常访问磁盘中的某组数据，复制到主存中作为一个副本
* 位置
    * 逻辑上属于磁盘，物理上就是主存中的一片区域
* 形式
    * 在内存池中开辟一个单独的存储空间，大小固定
    * 把未利用的内存空间作为一个缓冲池，供请求分页系统和磁盘IO共享
###### 缓冲区
* 目的
* 实现方法
* 实现形式
    * 缓冲区机制
        * 当缓冲区为空时，可以往缓冲区中装入数据，但是必须等缓冲区装满数据，才能把数据从缓冲区中传出
    * 单缓冲
        * 采用一个缓冲区
        * 处理一个缓冲区块的数据耗时为max（缓冲区装入时间T，CPU处理任务时间C）+缓冲区装入CPU时间M
            * 若T>C
                * 表明此时数据传送速率过低，BUFFER设置不够合理，每处理一块数据CPU等待时间为T+M-C
            * 若T<C
                * 表明CPU此时工作压力较大，CPU利用率高于T>C的情况，CPU等待时间为M
            * 注意：只有缓冲区数据全部装入CPU中，才可以开始任务处理
        * 缺点
            * 无论是T和C哪个更大，CPU总有时间浪费
        * 优点
            * 占用准存空间小，实现简单
    * 双缓冲
        * 采用两个缓冲区
            * 在一个缓冲区填满的情况下才能把数据填入另一个缓冲区
        * 处理一个缓冲区块时间耗时为max（C+M，T）
            * 若T>C+M
                * 传入速率较低，CPU空闲时间T-C，此时磁盘等块设备连续工作
            * 若T<C+M
                * CPU连续工作
        * 双缓冲区可以改造为全双工单缓冲通信，而单缓冲区只能采用半双工通信
        * 双缓冲可以使CPU无间断工作，单缓冲不可以
    * 循环缓冲
        * 采用多个缓冲区
        * 采用连接指针连接不同的缓冲区，最后一个链接第一个缓冲区，形式上像一个单循环链表
        * 采用IN OUt指针控制输入输出
    * 缓冲池
        * 由多个系统共用的缓冲区构成
        * 分为三个队列
            * 空缓冲队列
            * 装满输入数据的缓冲队列(IO设备到用户的数据)
            * 装满输出数据的缓冲队列（用户到IO设备的数据
        * 除了三种队列还需要四种缓冲区一起工作
            * 收容输入
            * 提取输入
            * 收容输出
            * 提取输出
        * 工作流程（附P307图）
            * iO向缓冲池写入数据
                * 从空队列中摘出1个缓冲区作为收容输入队列，IO写入数据，直到写满数据，入队至输入队列队尾
            * 用户向缓冲池装入数数
                * 采用收容输出缓冲池，
            * 缓冲池向IO输出数据
                * 采用提取输出缓冲池
            * 缓冲池向用户输入数据
                * 采用提取输入缓冲池
###### 高速缓冲与缓冲区对比
* P307
##### 作用：提高磁盘IO速度，解决与主存之间速度不匹配的问题
#### 设备分配与回收
##### 设备分配概述
###### 原则
* 尽可能让设备忙碌，且不发生死锁
###### 三类设备
* 独占设备
    * 互斥访问设备
* 虚拟设备
    * SPOOLING技术
        * 空间换时间
* （分时）共享设备
    * 对磁盘的IO请求分时交替进行
##### 设备分配的数据结构
###### SDT（system device table）系统设备表
###### DCT（device system table）设备控制表
###### DOCT（device control tale）控制器控制表
###### DHCT（device channel table）通道控制表
###### 各个数据结构之间的联系
* SDT->DCT->DOCT<->DHCT
###### 在分配一个设备的过程
* 设备可用-》控制器可用-〉通道可用
##### 设备分配的策略
###### 原则
* 设备特性
* 用户要求
* 系统配置情况
###### 分配方式
* 静态分配
* 动态分配
###### 分配算法
* 先请求先分配
* 优先级高者优先
##### 设备分配的安全性
##### 逻辑设备名到物理设备名到映射
###### LUT
###### logic unit table
#### SPOOLing技术
##### 基本条件：大容量高速度的外存作为输入井和输出井，需要多道程序设计的支持
##### 作用：可以让多个作业共享一台独占式设备
##### 输入井和输出井之间的数据传送由OS控制，用户无法控制
##### 输入井和输出井在磁盘中
##### 输入缓冲和输出缓冲在主存中
## 文件管理
### 概念
#### 文件是以计算机硬盘为载体的存储在计算机上的信息集合，文件可以是文本文档，图片和程序等
##### 计算机以进程为基本单位进行资源的调度和分配
##### 计算机以文件为基本单位进行用户的输入输出
##### 计算机以线程作为CPU调度的基本单位
#### 文件的组成
##### 存储空间（存储空间中的数据）
###### 书中的内容
##### 分类和索引的信息
###### 图书书籍编号
##### 访问权限的信息
###### VIP书籍借阅查询
#### 文件的结构化
##### 数据项
###### 基本数据项
* 最小逻辑数据单位（姓名，日期）
###### 组合数据项
* 由多个基本数据项组成
##### 记录
###### 由数据项组成
###### 描述一个对象的数据项集合属性，比如一名考生的报考学校代号，身份证号等信息
##### 文件
###### 一组相关信息的结合
###### 逻辑分类
* 有结构的文件
    * 记录式文件（所有考生报名信息）
* 无结构的文件（流式文件）
    * 字符流（txt）
#### 文件的打开与关闭
##### 文件的打开
###### 主要工作
* 把文件的属性或者说目录从外存复制到内存中的打开文件表中，记录该文件的物理位置
###### 文件指针
* 跟踪上次读写作为当前目录的指针，跟踪文件位置
###### 文件打开计数
* 用于记录当前有几个进程打开了这个文件，当COUNt为0时，系统关闭文件，把FCB从打开文件表中删除
* 设置打开计数器的目的就是控制打开文件表中的条目数量
##### 文件的阅读
###### 数据不在内存中，则该进程进入睡眠等待状态
###### 请求READ系统调用会使CPU从用户态切换到核心态
###### READ系统调用在OPEN之后，因此只需要提供三个参数
* 文件描述符FD
* buf缓冲区首址
* 传送的字节数n
### 文件的逻辑结构
#### 文件内部应该如何被组织起来，是用户观点出发看到的文件组织形式
#### 无结构文件
##### txt文件
##### 适用于基本信息不多的文件
#### 有结构文件
##### 顺序文件
###### 文件中的记录在逻辑上一个接一个的顺序排列，记录可以是定长的或者变长的，各个记录在物理上可以是顺序存储也可以是链式存储
###### 按照是否按照关键字序列排列
* 串结构
    * 记录之间的顺序与关键字无关
* 顺序结构
    * 记录之间的顺序按关键字顺序排序
###### 物理存储形式
* 顺序存储
    * 物理上也相邻
        * 可变长记录
            * 无法实现随机存取
        * 定长记录
            * 可实现随机存取，记录长度为L，直接加上偏移量即可
            * 串结构，无法快速查到记录
            * 顺序结构
                * 可以采用折半查找等算法优化查找速度
* 链式存储
    * 物理上不一定相邻
    * 无论是定长还是可变长，都无法实现随机存取
###### 优缺点
* 优点
    * 当每次都需要顺序读取一块记录时，顺序文件效率最高，也只有顺序文件可以存在磁带中
* 缺点
    * 增删改查单条文件耗时较多，相对来说串结构这种记录之间无顺序要求的要好于顺序结构
##### 索引文件
###### 解决大量可变长记录快速查找的问题
###### 通过索引表（本身是一种定长记录的顺序文件），来快速找到第I个记录对应的索引项，索引表的记录中存放着对应文件的物理位置
* 再通过这个索引项关联其对应记录，类似于SQL中的join操作
###### 若索引表按照关键字有序排列，则可以采用更佳的算法进行更快速的查找
###### 索引文件的关键字可以多种多样，一个文件可以采用多个关键字建立多个索引表
###### 缺点
* 每个记录都安排一个索引表项，如果文件中记录数太多，则索引表项会很大
* 类似于CACHE中的全相联映射
* 用于查找速度要求很高的文件中
##### 索引顺序文件
###### 解决索引表过大的问题
###### 为文件的一组记录建立一个表项存在索引表中，此时文件的索引表不一定是顺序结构的（对应串），因此增加索引表项比较方便
* 关键就是一个索引项对应一组记录，类似于组相连映射
###### 若不采用这样的索引
* ASL=N/2
###### 采用根号N个分组
* ASL=根号N/2+根号N/2
###### 如果记录很多可以建立多级索引
##### 直接文件或者散列文件
###### 全相联。HASH函数进行寻找
### 目录结构
#### 文件之间应该如何被组织起来
##### 实现目录结构所需的数据结构
###### 文件控制块（FCB file control block）
* 为了实现的文件按名存取
* FCB的有序集合就被称为文件目录，一个FCB就是一个文件目录项
* FCB主要包含信息
    * 基本信息
        * 文件名
        * 文件的物理位置
        * 逻辑结构
        * 物理结构
    * 存取控制信息
        * 访问权限
    * 使用信息
        * 文件创建和修改时间
###### 索引结点
* 对FCB的改进，仅包含文件名信息
* 基本构成为《文件名1，索引结点编号》
    * 索引结点编号指向索引结点这个数据结构
* 索引结点组成
    * 文件表示主符
    * 文件类型
    * 存取权限
    * 物理地址
    * 文件长度
###### FCB类似于图书馆书本的索书号，包含图书的所有信息的一个表，索引结点仅仅包含书名，只有点进去这个书名才能链接到书的具体信息
* FCB比较详细，在数目较少的文件系统中索引速度较快
* 大部分情况下索引结点目录访问目录更快
##### 目录结构
###### 单级目录结构
* 使用一张目录表，可以实现按名存储文件
* 缺点：查找速度慢，不允许重名，而且不能进行文件共享，这对于多用户系统非常不方便
###### 两级目录结构
* 由主文件目录（master file directory）和用户文件目录（user file directory）组成
    * MFD记录用户名和UFD所在位置，欲访问文件时只需通过MFD照对应文件目录进行访问
    * UFD则记录具体的FCB或者索引结点信息，用于访问文件主体
* 优缺点
    * 优点：解决了不同用户之间的重名问题，（具体文件可以重名，用户名不能重名）
    * 缺点：缺乏灵活性，不能对文件进行分类，一个用户的文件通常散乱存放
###### 多级目录结构（树形）
* 两级目录层次的推广
* 对于多级目录结构对应查找文件有两种路径
    * 绝对路径
        * /user1/dev/c++
        * 用于表示这个文件在文件系统中的绝对位置
    * 相对路径
        * ./c++
        * 用于表示这个文件的相对路径，即用省略号代替目前文件路径。通过合理设置相对路径，可以j减少IO次数，加快访问速度
* 优缺点
    * 优点：可以实现文件分类，层次结构清晰
    * 缺点：不能实现文件共享，只能按路径名顺序查找（B+树），效率不够高
###### 无环图目录结构
* 无环图目录结构
    * 为了实现共享功能，在树形目录的基础上增加了一些指向同一结点的有向边
    * 采用共享文件的方式，在删除一个共享结点时，不应该简单删除对应文件，因为会造成其他共享用户访问出错
        * 设置一个文件访问计数器，当计数器为0时，才能删除对应共享结点
        * 这里这种连接方式实际上是硬连接
    * 共享文件与拷贝不同，指的是不同的用户目录指向同一个存储在磁盘上的文件，任何改变都能被所有用户看到（类似于石墨文档）
    * 优缺点
        * 优点：实现了文件的共享
        * 缺点：使系统的管理变得更加复杂
##### 文件共享
###### 硬链接
* 多个用户的目录指向同一个索引结点
* 索引结点中需要有链接计数器COUNT
* 用户想删除文件时，只是删除该用户的目录项，且COUNT—
* 只有COUNT==0时，才能真正删除文件数据和索引结点，否则会导致指针悬空
* 若文件F1的硬链接为F2，两个进程分别打开这两个文件，获得文件描述符分别为FP1和FP2
    * F1与F2共享一个内存索引结点（指向磁盘中同一个文件）
    * FD1和FD2为指向一个进程中该进程打开文件的指针，即FD1->索引表文件->打开文件表中的对应选项
    * F1和F2各自维护自己的读写指针，不必保持同步
###### 软链接
* 在一个LINK类型的文件中存放共享文件的存放路径（windoes快捷方式）
* 操作系统根据保存的路径一层层查找目录，最终找到共享文件
* 即使软链接的共享文件已经被删除，LINK类型的文件依然会保存在系统中，只是通过这个LINK类型的文件访问会失败
    * windows中快捷方式所指向项目已被删除
* 用软链接的方式访问共享文件时要查询多级目录，会有多次磁盘IO，因此用软链接的方式访问共享文件的速度要比硬链接更慢
* 也会设置一个COUNT计数器，建立软连接时，文件链接计数值直接复制
##### 文件保护
###### 访问权限
* 访问权限表为一个矩阵，若有四类用户五种状态，则需要20位的空间来描述文件权限
    * 该矩阵可以称为存取控制矩阵，访问控制矩阵，用于防止系统故障而造成文件受损
###### 加密保护
* 由用户实现，安全性高
    * 密钥：用户对文件进行加密，访问文件时需要输入密钥
    * 口令：建立FCB时附上口令，存储在系统内部
###### 访问控制
* 由系统实现，安全性较差，灵活性高
### 文件的物理结构
#### 文件如何存放在外存中
##### 目录物理结构
###### 线性表（链表）
###### 哈希表
##### 文件物理结构
###### 连续分配（顺序表）
* 碎片
    * 内部碎片
        * 被静态分配的存储块，不被进程占用却不能被其他进程使用
    * 外部碎片
        * 还没被分配出去但是单块太小了无法被其他进程使用
    * 页内碎片
        * 极小的内部碎片，但是不叫内部碎片，基于非连续存储模式
* 采用在磁盘上连续分配一整块空间的方式来存储文件，类似于顺序表存储4 ，
* 目录项内容
    * 起始块号，文件长度（表明要顺序读取几个块，最后一个块即使没装满也不会再分配给其他文件）
* 优缺点
    * 优点
        * 同时支持顺序访问和直接访问，实现简单，存取速度快
    * 缺点
        * 文件长度动态增加麻烦，一旦需要增加就要移动大量的磁盘块，此外反复增删文件会产生外部碎片，因此只适用于长度固定的文件
* 访存一次
###### 链接分配（链表）
* 隐式分配
    * 把内存区域离散化，采用指针链接不同的磁盘块，消除了内部碎片，并且增加或删除一个区域也不用移动大量盘块
    * 目录项
        * 起始块号，结束块号
    * 缺点
        * 若中间有一块数据丢失，则整个文件就有丢失的风险，稳定性较差，而且基于其链表的特性，只支持顺序访问
* 显式分配
    * 在链式分配的基础上，添加了一张FAT（file allocation table），标明（盘块号，下一块号）
    * 目录项
        * 起始块号
        * 在哪里结束由FAT中下一块指针为-1作为结束标志
    * 优缺点
        * FAT在系统启动时就会被读入内存，因此不仅显著提高了检索速度，而且明显减少了访盘次数
        * 缺点
            * 占用主存空间和磁盘空间，如果有大量的磁盘块需要记录那么占用的空间还是比较大的，属于用空间换时间的做法
* 访存N次，因为每一个磁盘块都需要分批读入内存
###### 索引分配（索引表）
* 链接方案
    * 把索引表以块的方式存储在磁盘当中，索引块之间采用指针链接
    * 每个索引块都指向文件名对应的索引结点，再对应文件，读取一个文件只需要两次访盘
    * 缺点：在大文件读取中索引表占用空间太大，并且由于链式存储的特点，读取索引表中中间一部分文件也需要便利索引表的前n-1项，时间开小较大
* 多层索引
    * 解决需要访问前N块的问题
    * 缺点：即使是小文件也需要根据分级结构多次访盘，时间开销比较大
* 混合索引
    * 采用直接地址访问和多级索引结合的方式
    * 小文件可以采用直接访问，大文件采用多级访问制度
    * 重要考点
        * 会根据多层索引和混合索引计算出文件的最大长度（各级索引表大小不能超过一个块）
        * 要能分析访问某个数据块需要的访盘次数
            *  FCB中存有指向顶级索引块的指针，因此可以根据FCB读入顶级索引块，每次读入下一级的索引块都需要一次读盘操作
            * 要注意顶级索引块是否已经调入内存中，一般来说ROOT目录都在内存中
* 优缺点
    * 优点
        * 支持随机访问，易于实现文件的拓展
    * 缺点
        * 索引表需要占用一定的存储空间
        * 访问数据块之前要先在磁盘中访问索引块，如果建立多级索引，那么就需要多次IO，一般来说M级索引需要M+1次访存
* M级需要访问M+1次
###### 实现逻辑上的顺序文件
### 存储空间的管理
#### 操作系统如何管理外存中的空闲块
##### 空闲表
###### 连续分配方式
###### 空闲盘区分配
* 类似于内存的动态分配
* 采用首次适应或者循环适应
###### 回收
* 同样类似于内存分配
    * 考虑是否与前驱后者后继相链接，如果是的话要进行合并，即进行紧凑，尽量减少外部碎片
##### 空闲链表
###### 空闲盘块链
* 以空闲盘块为单位组成一条空闲链
###### 空闲盘区链
* 以空闲盘区为单位组成一条空闲链
###### 盘区就是一组相领的盘块，采用把一组盘块链接在一起的方式进行指针链接，可以减少指针的数目，提高存储效率
##### 位示图
###### 采用类似于二维数组的机制进行空闲和忙碌块的管理
###### 分配的流程
* 如果从0开始编号（行列均从0开始编号）
* 则位示图坐标（i，j）对应的物理盘块号为i*n+j，类似于二维数组存在一维数组中的存储方法
* 修改位示图 令m（i，j）=1
###### 回收的流程
* 若从0开始，则i=b/n ，j=b%n
* 若从1开始   则i=（b-1）/n+1.                               j=（b-1）%n+1
* 修改位示图 令m（i，j）=0
##### 成组链接法
###### UNIX采用的策略，适用于大型文件系统，理解即可
##### FAT（文件分配表）
###### 也可用作空闲磁盘块的管理，可以把空闲块置-2或者-3
### 操作系统需要提供的其他文件管理功能
#### 文件共享
#### 文件保护
### 磁盘
#### 磁盘的结构
##### 磁盘 磁道 扇区的概念
###### 磁盘由表面涂有磁性物质的圆形盘片组成
###### 每个盘片被划分为一个个磁道，每个磁道又被划分为一个个扇区
##### 如何在磁盘中读写数据
###### 磁头移动到目标位置，盘片旋转，对应扇区划过磁道才能完成读写
##### 盘面和柱面的概念
###### 磁盘有多个盘片摞起来，每个盘片有两个盘面
###### 所有盘面中相对位置相同的磁道组成柱面
##### 磁盘的物理地址
###### （柱面号，盘面号，扇区号）
##### 磁盘的分类
###### 根据磁头是否可移动
* 固定头磁盘（每个磁道有一个磁头）
* 移动头磁盘（每个盘面只有一个磁头）
###### 根据盘片是否可以更换
* 固定盘磁盘
* 可换头磁盘
#### 磁盘调度算法
##### 读盘延迟时间=寻道时间+延迟时间（转半圈需要道时间）+传输时间
###### 这些时间都是针对一个磁道而提出的，若一个磁道可以存储N个字节，则读取b字节数据所需时间为b/N*平均时间
##### 磁盘调度算法
###### 先来先服务
* 优点
    * 公平，简单，不会出现饥饿现象
* 缺点
    * 平均寻道距离大，可能会出现饥饿现象
###### 最短寻找时间
* 优点
    * 性能优于先来先服务
* 缺点
    * 不能保证平均寻道距离最短，可能出现饥饿现象
###### 扫描算法
* scan算法（电梯调度算法）
    * 严格移动到最远端在回来
* LOOK算法
    * 对SCAN的改进，可以不用移动到磁盘的最远端就回来
* 优点
    * 寻道性能较好，可以避免饥饿现象
* 缺点
    * 不利于磁头远端的访问请求
###### 循环扫描算法
* C-scan
    * 与SCAN不同的是到达最远端之后磁头再移动到最近端，在进行扫描
    * 优点：消除了对两端磁道请求的不公平
* c-look
    * 最远端为页面的最远端，最近端为页面的最近端
###### 综上：look算法是对scan算法的改进，look算法的最远端是欲访问页面的最远端或者最近端，scan算法的最远端是整个磁盘的最远端或者最近端
#### 磁盘的管理
##### 磁盘初始化
###### step1
* 进行低级格式化，将磁盘的各个磁道划分为扇区，并确定所需数据结构和各种扇区校验码
###### step2
* 对磁盘进行分区，每个分区由若干个柱面组成，为什么由相邻柱面组成主要是因为同一柱面寻道时间较短
###### step3
* 进行逻辑格式化
    * 创建文件系统
        * 根目录
        * 空闲磁盘管理数据结构
            * 位示图
            * FAT
##### 引导块
###### 计算机启动时需要运行初始化程序（自举程序）来完成初始化
###### ROM存放很小的自举装入程序
###### 完整的自举装入程序存放在初始块（引导块）中
##### 坏块的管理
###### 简单的磁盘：逻辑格式化将对坏块标记出来
###### 复杂的磁盘：磁盘控制器维护一个坏块链，并管理备用扇区
## 概论
### OS的基本概念
#### 概念
##### 负责管理协调硬件，软件等计算机资源的工作
##### 为上层用户，应用程序提供简单易用的服务
##### 是一种系统软件
#### 功能与目标
##### 资源的管理者
###### CPU管理（进程管理）
###### 存储器管理
###### 文件管理
###### 设备管理
##### 向上层提供服务
###### 给普通用户的
* GUI用户图形界面
* 命令接口
    * 联机命令接口
    * 脱机命令接口
###### 给软件/程序员的
* 程序接口
    * 系统调用
##### 对硬件机器的扩展
###### 从逻辑上拓展内存空间
### OS的特征
#### 并发
##### 宏观上并行，微观上串行
#### 共享
##### 互斥共享方式
##### 同时共享方式
#### 虚拟
##### 空分复用技术
##### 时分复用技术
#### 异步
##### 即由于程序的并发执行，指令与指令之间的顺序在没有采用同步机制的系统中可能会出现乱序
### OS的发展与分类
#### 手工操作阶段
##### 人机速度矛盾
#### 批处理阶段
##### 单道批处理系统（引入脱机输入输出技术）
###### 优点：缓解人机速度矛盾
###### 缺点：资源利用率仍然很低
###### 即可以把磁带传入计算机中，按照顺序处理好磁带上的作业
##### 多道批处理阶段（操作系统开始出现）
###### 优点：多道程序并发执行，资源利用率高
###### 缺点：不提供人机交互功能
##### 分时操作系统
###### 优点：提供人机交互，尽可能快的响应用户
###### 缺点：不能优先处理紧急任务
##### 实时操作系统
###### 硬实时系统
* 必须在绝对严格的规定时间内完成处理
###### 软实时系统
* 能接受偶尔违反时间规定
###### 优点：能优先处理紧急任务
##### 网络操作系统
##### 分布式操作系统
##### 个人计算机操作系统
### OS的内核
#### 内核功能
##### 时钟管理
##### 中断处理
##### 原语
##### 对系统资源进行管理的功能
###### 进程管理
###### 存储器管理
###### 设备管理
#### 运行机制
##### 两种指令
###### 特权指令
###### 非特权指令
##### 两种处理器状态
###### 核心态
###### 用户态
##### 两种程序
###### 内核程序
###### 应用程序
#### 操作系统的体系结构
##### 大内核
###### 高性能
###### 内核代码庞大，结构混乱，难以维护
##### 微内核
###### 内核功能少，结构清晰，方便维护
###### 需要频繁的在内核态和用户态之间切换，性能低
### 中断和异常
#### 中断的作用
##### 让OS内核强行夺回CPU的控制权
##### 使CPU从用户态转变为内核态
#### 中断的分类
##### 内中断（异常，例外）
###### TRAP指令
* 可以认为是人为输入一个非法指令进入管态，比如输入了1/0
* 是通过陷阱指令预先设定的一类内部中断事件
* 可用于实现程序调试时的断点设置和单步跟踪
* 自陷发生后CPU将转去执行操作系统内核相应程序
* 自陷处理完成后返回到陷阱指令的下一条指令执行
###### 故障（fault）
* 访存时缺页
* 除以0
###### 终止（abort）
###### 内中断都是不可屏蔽中断，即使CPU在关中断状态下也会响应
###### 内中断的优先级高于外中断，一条指令执行结束才回去执行外中断，而内中断无论何时发生，都会被响应
##### 外中断
###### 也称为可屏蔽中断，在关中断时不会被响应
###### 这类中断的产生通常与当前发生的事件无关
###### 常见外中断事件
* 时钟中断
* IO请求中断
* 网络数据包到达
###### 响应外中断有3个条件
* 中断源有中断请求
* CPU允许中断及开中断
* 一条指令执行完毕，且没有更紧迫的任务
#### 中断机制的基本实现原理
##### 检查中断信号
###### 内中断：CPU在指令执行时会检查是否有异常发生
* 浮点数上溢
###### 外中断：每个指令周期的末尾会检查，主要是检查是否有中断传输信号，iO设备数据输入等
##### 找到相应的中断处理程序
###### 通过中断向量表来实现
##### 操作系统实现
###### 提供中断服务
###### 初始化中断向量表
###### 保存中断屏蔽字
##### 硬件实现
###### 关中断
###### 保存断点
* PC
* PSW
###### 引出中断向量地址
### 系统调用
#### 什么是系统调用
##### OS对应用程序和程序员提供的接口
#### 系统调用和库函数的区别
##### 有的库函数是对系统调用的进一步封装
##### 有的库函数没有使用到系统调用
#### 为什么系统调用是必须的
##### WORD和WPS同时打印，若过不采用OS对进程的统一管理，打印出来的内容就会出错
#### 什么功能要用系统调用实现
##### 设备管理
##### 文件管理
##### 进程控制
##### 进程通信
##### 内存管理
##### 凡是与共享资源有关的操作，会直接影响到其他进程的操作，就一定需要OS介入，就需要通过系统调用来实现
#### 系统调用的过程
##### 传递系统调用参数
##### 陷入指令/trap/访管
##### 由OS内核程序处理系统调用请求大家
##### 返回应用程序
