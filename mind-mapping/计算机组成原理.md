# 计算机组成原理
## 输入输出系统
### I/O系统基本概念
#### IO端口与IO接口的的区别
##### 1.IO接口是物理上存在的连接接口
##### IO端口是接口中各式样的寄存器，包括data buffer register pew 等，一个接口中通常包括多个端口
##### IO接口别名叫做设备控制器，用于外部设备与主机通信
### IO接口
#### IO总线上的数据线传输的内容包括
##### 数据缓冲寄存器
###### 数据
##### 控制/状态寄存器
###### 命令字
###### 状态字
###### 中断类型号‘
###### 也从一个侧面说明了状态端口和控制端口可以合用一个寄存器（IO端口）
#### 编址方式
##### 统一编址
###### 地址固定在内寸的某一块
* 高位
* 低位
* 中间
###### io指令为访存指令，从内存中取出对应指令
##### 独立编址
###### 独立地址，无法由地址码区分
###### 需要专门的IO指令
##### 这两种地址程序员都无法直接访问，在编程层面访问设备只能使用逻辑地址
### IO控制方式（前两种用于低速设备‘）
#### 程序查询方式
##### 1.每次查询传输的数据块大小为数据缓冲寄存器大小
##### 2.为保证数据不丢失，每个数据块都查询一次即可
##### 3.占用CPU大量资源，cpu与外设串行工作，主程序与传输串行工作
##### 4.CPU时间占比计算
###### 每秒查询次数*查询一次需要的时间周期/CPU主频
#### 程序中断方式
##### 1.每传输一个字就需要进行一次中断
##### 2.中断响应与中断处理
###### 中断响应（优先级不可由屏蔽字更改）
* 关中断
* 保护断点（pc）
    * 不允许断点即程序状态字和当前指令被打乱
    * 因为中断程序通常由多条指令组成，而电脑中只有一个PC
    * 通常可以把这个断点压入堆栈中保存起来
* 硬件通过产生中断类型号
    * 硬件产生中断类型号
    * 中断类型号通过数据总线传播
    * 中断类型号指出了中断向量存放的地址，CPU收到中断向量地址送入PC
###### 中断处理（优先级可以由屏蔽字更改）
* 保护现场
    * PSW
    * 中断屏蔽寄存器
    * CPU中某些通用寄存器
* 开中断
    * 允许中断嵌套
* 中断服务程序启动
* 关中断
    * 不允许现场恢复被打断
* 恢复现场
###### 中断屏蔽字规则：如ABCD四个中断源，想更改处理优先级为dcba，则屏蔽字分别为1000，1100，1110，1111
###### 单级中断系统
* 关中断
* 保存断点
* 识别中断源
* 保存现场
* 中断事件处理
* 回复现场
* 开中断
* 中断返回
* 硬件完成
* 程序完成（程序没有关中断的过程），因为硬件已经把中断关掉了，不需要多级嵌套中断
##### 两种时间计算方式
###### 每个字符完成传输任务所需要的时钟周期：字符传输时钟周期+中断响应时钟周期+中断处理时钟周期（到启动设备的指令就可以结束了）
###### Cpu用于中断所需要的时钟周期：中断响应+中断服务程序
##### 工作方式
###### CPU与外设并行工作
* 与询问等待不同，外设准备好传送数据之后再向CPU发起中断请求，在准备数据阶段不占用CPU使用
###### 传送数据与CPU（主程序）串行工作
* 但是在数据传输阶段还是需要中断CPU当前执行任务进行数据传输，因此在数据传输阶段与CPU并行
* 而且每次只能传送一个数据寄存器大小的字符块，小于DMA块，中断周期又长于存储周期，因此效率比起DMA差了很多
#### DMA方式（数据传送通过硬件完成）
##### 1.与内存之间直接开辟一条数据通道，以内存页面（一般位4kB)为单位进行数据传输
###### 这条通道为数据通路，由总线桥接而成，不是物理意义上的通路
##### 2.鉴于1的特殊性质，他在数据传输时与主程序也可并行，在每个访存周期（机器周期）之后均可进行数据传输，与主程序并行工作。
##### 3.周期窃取，当dma想访问主存时，cpu正处于间地址或者其他访存阶段，可以在机器周期之后访问占用总线，访问主存
##### 4.时间周期
###### 1.占用CPU时间周期
* （预处理+后处理）*传输块数/机器主频
##### DMA几种重要的硬件性质
###### DMA传送前由cpu依据驱动设备程序设置传送参数
###### 数据传送前由DMA控制器请求总线控制使用权
###### 数据传送由DMA控制器控制总线直接完成
###### dma传送结束后的处理由中断服务程序完成
#### 通道方式
##### 通道是一种外设，挂接多个高速设备其运行程序位于主存中，由通道取出并由通道执行，并且只能在有通道的IO系统中执行
### 外部设备
#### 408常考察磁盘和显示器
##### 1.显示器：显存带宽等于分辨率（多少个像素）*颜色深度（一般以位作为单位）*帧频（一秒钟刷新多少次）
##### 磁盘
###### 磁盘单位
* 最小寻址单位：扇区
* 文件读取最小单位：磁盘块，通常由二的整数幂个扇区组成
* 内存最小寻址：内存块
* 内存数据通路单位：页
* 最小空间分配单位：cluster（族）
###### 磁盘读取时间（这里最好放个磁盘的图）
* 查询时间=磁道寻找时间+扇区延迟时间+控制器延迟时间+传输时间
* 寻道时间：通常比较长，为磁臂寻找磁道道时间
* 扇区延迟时间：磁盘转半圈所需要的时间
* 控制器延时：接口延时，通常会给出
* 传输延时：磁盘块/扇区➗传输速率
###### 磁盘格式化和内容
* 磁盘格式化后的容量比非格式化容量小，因为放入了索引占据磁盘空间
* 扇区中包含1.数据2.地址3.校验
* 磁盘存储器由磁盘控制器，磁盘驱动器和盘片组成
###### 地址：柱面号-盘面号-扇区号（块号）
## 总线
### 6.1总线概述
#### 定义：总线是公共信息传送线路
##### 分时：主设备发送信息串行
##### 共享：从设备接受信息串行
#### 突发传送方式
##### 在一个总线周期内传输到一个地址多个数据字
###### 若总线宽32位，地址/数据线复用，则传输128位的数据需要占用128+32（地址）/32=5个时钟周期，作为一个总线周期
#### 结构
##### 单总线结构
###### 由一条系统总线链接所有设备
* 由三种总线组成：地址，数据，控制总线
##### 双总线结构
###### 主存总线，IO总线
* 实现存储器和IO设备的分离
    * IO总线的数据传递方向
        * 地址总线
            * 单向传播（CPU->主存或者iOS设备）
            * 存储器和IO设备的地址码
        * 控制总线
            * 单向传播
            * 所有存储器和IO设备的时序和逻辑控制信号
            * 来自IO设备和存储器的响应信号
        * 数据总线
            * 数据双向传播
            * 可以有IO接口中的命令字，状态字，中断类型号等等信息
##### 三总线
###### 主存总线，IO总线，DMA总线
* 频繁切换总线，效率较低
#### 若设计一个所有指令周期都为一个时钟周期的cpu
##### 1.不可采用单总线结构，因为不同部件的控制信号无法并发传输
##### 2.处理器时钟频率低，因为有的指令需要的机器周期少，有的机器周期多，机器周期少的要为机器周期多的让步
##### 3.在指令执行过程中控制信号不变，因为控制信号只有在不通的时钟周期之间才会切换
##### 4.每条指令的cpii都为1，显然，每条指令都只需要一个时钟周期
### 6.2总线操作与定时
#### 1.同步定时
##### 整个系统都采用同一个时钟
###### 1.适用于总线长度短，各部件时钟周期差不多的系统，不然会有长时间等待的情况发生
###### 2.强制性同步，不能及时进行数据通信的有效性检验，可靠性差
#### 2.异步定时
##### 没有时间制约，采用握手方式进行制约‘
###### 不互锁
* 发送方与接收方均无确认帧
###### 半互锁
* 接收方需要发送确认帧，不然发送方会超时重传
###### 全互锁
* 发送方和接收方均需要发送确认帧，且均会超时重传
### 6.3总线标准
#### USB总线
##### 注意和IO端口区分，IO端口是组成接口的寄存器
###### 注意和IO端口区分，IO端口是组成IO接口的几个寄存器
##### 串型传输
##### 即插即用
##### 热拔插
##### 有很强的连接能力，可以采用菊花链形式将众多外设连接起来
##### 具有很好的可扩充性，一个USB控制器可以扩充高达128个设备
##### 高速传输，速率可达480Mb/s
## 指令系统
### 指令格式
#### 定长操作码的指令格式
##### 高位固定位数用作操作码，当计算机机器字长很长时（>32）,定长操作码是普遍选择
#### 子主题 3
##### 指令的构成
###### 操作码
* 由cpu控制器器中的译码器翻译
###### 地址码
* 由主存中的地址译码器进行翻译
##### 宏观组成
###### 指令集：与指令系统是一个东西，指的都是整个计算机所有指令的合集
###### 指令系统是计算机软件与迎接交接的界面
#### 扩展操作码的指令格式
##### 类似于哈夫曼编码，从高位开始编址，留出一个1111，用于1111xxxxx编址，类似这种方式
##### 特点
###### 1.不允许短码是长码的前缀，否则在译码时会有歧义
###### 2.各指令的操作码不能重复
###### 3.对使用频率较低的指令分配长的操作码，使用频率较高的指令分配短的操作码
### 指令的寻址方式
#### 有效地址的概念
##### 逻辑地址：指令中的地址码字段不代表操作数的真实地址，而且一种与真实地址之间的映射，这种地址称作逻辑地址，也称为虚拟地址。（程序员在编程时只能接触到虚拟地址）
##### 物理地址（有效地址）：操作数在存储器中的真实地址，由逻辑地址结合寻址方式计算而出
#### 数据寻址和指令寻址
##### 指令寻址
###### 顺序寻址：pc+1,这里这个1是指一个指令字长，可能在主存空间中占用了不同大小的主存块
###### 跳跃寻址：即通过转移指令进行地址之间的条约
* 1.无条件转移
    * 下一条指令的地址为PC+1+偏移量
* 2.条件转移
    * 转移成功：与无条件相同
    * 转移失败：pc+1
##### 数据寻址
###### 隐含寻址
* 一个操作数隐含在一个硬件中，访存次数为0，有效缩短指令长度
    * 0
###### 立即数寻址
* 地址字段直接给出操作数本身，访问速度快，访存次数为0，但是立即数寻址的范围通常比较小
    * 0
###### 直接寻址
* 直接给出数据在主存中存放的地址，访存次数为1
    * 1
###### 间接寻址
* 在指令中给出操作数的间接地址，可以是一次间接也可以是多次间接，一次间接寻址访存次数为2
    * n+1
###### 寄存器寻址
* 指令给出寄存器编号，以片选的方式选择寄存器，直接读出寄存器中的数据
    * 0
###### 寄存器间接寻址
* 指令中给出寄存器的编号，寄存器中存放的是数据在主存中的存放位置
    * n
###### 相对寻址
* 1.用于转移指令
* 2.用于多道程序的沉浮，且范围大，因为转移指令的转移范围是以主存单位计算的
    * 1
* 3.是多道批处理中最重要的寻址方式
* 4.指令中给出的地址码为相对于PC的偏移量，其寻找的并非操作数，而是下一条指令的地址
###### 基址寻址
* 1.基址寄存器面向操作系统的数据不可以编辑
* 2.可以用于小范围指令之间的转移
* 3.基址寄存器中的数据作为基地址，不可修改，而指令字中的值作为偏移量可以修改
###### 变址寻址
* 1.通用寄存器中的IX值可以修改
* 2.指令字中的值作为基地址不能修改，而寄存器中的数字作为偏移量可以修改
* 3.主要用于数组的遍历
###### 堆栈寻址
##### 大端存储和小端存储
###### 大端：最高有效字节存在内存的低位
###### 小端：最高有效字节存在内存的高位
###### 最高有效字节：编码中权重最高的那位
###### 有效地址：无论是大端存储还是小端存储，其真实的地址反映在PC中均为其在主存中的最低位地址
#### 常见寻址方式
### 两种指令集计算机
#### CISC（complex instruction set computer）
##### 1.指令数量庞大，指令的长度也不固定
##### 2.可以访存的指令数量不受限制
##### 3.各种指令之间的执行时间相差很大，大多数指令需要多个时钟周期才能完成
##### 4.由于指令数量太多，采用硬布线完成的话控制线路太过复杂，因此多采用微程序控制
##### 5.打车->吃饭->付钱和并在一个指令中，控制咯即复杂，还要实现进程的同步
##### 6.其广泛应用离不开超大型规模集成电路的广泛使用
#### RISC(reduced instruction set computer)
##### 1.一定采用流水线技术，大多数指令在一个时钟周期内完成
##### 2.指令长度长短固定（可以用于判断408的大题中是CISC还是RISC）
##### 3.只有LOAD和STORE指令访问主存，其他的都在寄存器之间进行
##### 4.采用硬布线为主，不用或少用微程序
##### 5.可以用简单的RISC中的指令编写出复杂的功能，可以通过编译程序实现高并发
##### 6.RISC中的指令都是从CISC中挑选出来的，最高使用频率的指令，而非为了实现和CISC的兼容
##### 7.目前短制程，ARM架构精简指令的处理器已经崭露头角，苹果M1就很适合用这样的处理器，因为他不需要于过往的OS，APP实现兼容
## 中央处理器
### CPU基本结构
#### 运算器
##### ALU，暂存寄存器，IX，累加寄存器，PSW，移位器，计数器
#### 控制器
##### PC，IR，MAR，MDR，时序系统，指令译码器（注意不是地址译码器，地址译码器在主存中）
#### 对程序可编程的寄存器
##### 通用寄存器，程序状态字寄存器，程序计数器
### 指令执行过程
#### 取地址
##### 特点：自动进行（不需要控制器给到指令），并且只能从PC中取出地址
###### 一般情况下是自增1，但是要注意这个自增1表示的是一个指令字长，一个指令字可能在主存中占用多个主存块，在存储层面上可能+2 +3.
##### 一个取地址周期不一定对应一个机器周期
###### 指令字长等于存储字长，取址周期等于机器周期
###### 指令字长等于多个存储字长，取址周期等于多个机器周期
###### 因此各条指令的机器周期数可变，各机器周期的长度也可变
#### 间地址
##### 取操作数（并非操作码），操作码由控制系统翻译要做什么事情
###### 1.先由指令寄存器给出真实地址在主存中的位置，这里的地址存储在mar中
###### 2.由主存返回真实地址，给MDR！！！，经由BUS返回到CPU
#### 运行
##### 一般来说都是考的加法操作，需要注意在单总线系统中，必须要有一个暂存寄存器用作运算
#### 中断
##### 采用中断方式存储程序断点
###### 1.SP--，开辟堆栈空间，因为堆栈是开口向下的栈，位置0为栈顶方向
###### 2.CU给出写命令
###### 3.写入到主存对应位置，地址由PC给出
#### 几个周期时长的关系
##### 不同机器周期耗时可能不同
###### 因此采用耗时最长的机器周期作为整个指令的机器周期，也称为CPU周期，一般为取指阶段
### 数据通路的功能和基本机构
#### 数据通路：数据在功能部件之间的传送路径（特别注意不含控制部件）
##### ALU
##### IX
##### PSW
##### 组合逻辑电路和时序逻辑电路
##### 中断部件
#### 主要考察硬布线和微程序之间不同节拍的书写
##### 1.硬布线的控制信号一般都是硬件信号SRin,MDRin等
##### 2.微程序控制信号需要由AD（CMDR）->cmar
### 控制器的功能和工作原理
#### 硬布线（硬件逻辑）
##### 节拍步骤，以取地址为例子
###### 0 pc-mar 
###### M(mar)-mdr pc+1-pc
###### Mdr-IR
#### 微程序（软件设计）
##### 微程序与指令之间的关系
###### 普通指令
* 由一个或多个机器指令构成
###### 机器指令（取地址指令）
* 对应一个微程序
* 对应一个机器周期
###### 微程序
* 由多个微指令构成
###### 微指令
* 由多个微命令构成
###### 微命令
* 与微操作一一对应，控制的最小单位，不可再分
###### 微操作
* 微命令的执行过程
###### 微周期
* 读取一条微指令并执行响应微操作的时间
##### 微命令执行步骤
###### Pc-mar
###### Ad(cmdr)-cmar
###### M(mar)-mdr pc+1-pc
###### Ad(cmdr)-cmar
###### Mdr-ir
###### Op(ir)-微地址形成部件-cmar
##### 微指令的格式
###### 水平型微指令：可以并行定义几种基本操作，一次可以完成多个基本操作，指令较长，编写程序麻烦
###### 垂直型微指令：只能定义一个基本操作，
###### 混合型微指令：在垂直型的基础上加上一些不复杂的并行操作
##### 微指令的编码方式
###### 直接编码
* 无需进行译码
* 选用不选用哪个微命令，在操作控制字段置0或1即可
* 优缺点
    * 简单，直观，执行速度快，操作并行性好
    * 微指令过程，n个微命令要求微指令操作字段有位
###### 字段直接编码
* 在直接法的基础上引入片选机制，每个小段留出一个状态作为不发出任何微命令，需要有译码过程
* 需要区分互斥性微命令，比如5个互斥类，有7 2 15 5 6个微命令，则需要8 3 16 6 7 片选之后为3+2+4+3+3=15个操作控制字段
* 互斥性微命令分在一个段内，相容性微命令分在不同段内
###### 字段间接编码
* 称为隐式编码，某些微命令由另一个字段解释，进一步缩短微指令字长。
##### 微指令地址形成方式
###### 通常可以通过这个位数来计算微指令最大条数
###### 断定方式
* 直接由微指令的下地址字段给出，即微指令操作控制码之后直接给出微指令的下地址
###### 首地址方式
* 根据机器指令的操作码形成，机器指令取至IR中，微指令的地址由操作位经微地址形成部件形成。
#### 控制方式
##### 同步
###### 统一时钟
##### 异步
###### 握手
##### 联合
###### 大部分同步，小部分异步
#### 控制存储器
##### 在CPU之内
##### 存储计算机系统中所有微指令
##### 采用rom实现
##### 按照微指令地址寻址
### 指令流水线技术
#### 串行执行方式
##### 优点：控制简单，硬件代价小
##### 缺点：指令执行速度慢，各功能部件利用率低
#### 流水行执行方式
##### 缺点：控制复杂
##### 优点：利用率高：
##### 考试一般采用五段流水线：取指，译码，执行，访存，写回
##### 表示方法
###### 指令执行过程图：主要用于分析指令以及影响流水线的因素（数据相关）
###### 时空图：主要用于分析流水线的性能
* 吞吐率
    * 等于完成任务数/时钟周期数
* 加速比
    * 流水线时钟周期/顺序执行时钟周期
* 效率
    * 部件使用比率，等于kn/k*（k+n-1），在时空图中就等于时空图不规则图形面积/整个矩形的面积
##### 影响指令流水线的方式
###### 结构相关
* 与OS中互斥问题类似
    * 由于多条指令在同一个时刻征用同一个资源而形成的冲突称为结构相关（访问同一个寄存器）
    * 解决办法
        * 1.后一相关指令暂停一个机器周期（时间）
        * 2.资源重复配置，数据存储器+指令存储器（空间），分配指令cache和数据cache是同一个道理
        * 3.可以看出指令cache和数据cache的分离有利于提高指令流水线的速度
###### 数据相关
* 与OS中的同步问题类似
    * 数据相关指的是必须等前一条指令执行完毕之后才可以执行后一条指令的情况）
        * 核心原因是写回第一条指令的数据需要经历五个机器和周期，但是后续指令可能在一个机器周期之后就进入了运行，因此如果直接运行会导致数据出错，所以就需要等待第一条指令执行完毕而不能乱序，因此出现了数据冲突
    * 解决办法
        * 1.等待
            * 硬件阻塞（硬件），由硬件插入bubble点时后续指令往后延迟执行
            * 软件插入（NOP），空指令，什么也不做，仅仅PC自增，汇编语言程序猿可以修改PC，因此可以人为插入空指令
        * 2.数据旁路技术
            * 不从写回的寄存器中取出数据，从EX指令阶段直接取出操作数
        * 3.编译优化
            * 通过编译器调整指令顺序来解决数据相关
###### 控制相关
* 当流水线遇到转移指令断流
    * 解决办法
        * 1.转移指令的分支预测
            * 简单预测
            * 动态预测
        * 2.预先取得转移成功和不成功两个控制流方向上的目标指令
        * 3.加快和提前形成条件码
        * 4.提高转移方向的猜准率
* 函数调用
###### 流水线的多发技术
* 超标量技术（同一个时间并发叠加多条指令）
    * 每个时钟周期并发多条独立指令
    * 需要配置多个功能部件
    * 不能调整指令的执行顺序
    * 运算操作串行执行，不可能并行
    * 不能调整指令的执行顺序
    * 空分复用
        * 同一时间多个硬件处理多个指令
* 超流水线技术
    * 一个时钟周期内再分段
    * 一个时钟周期内一个功能部件使用多次
    * 控制逻辑比较复杂
    * 不能调整指令的执行顺序
    * 时分复用
        * 对原来时间周期再做划分，继续细分一个机器周期，在一个机器周期内可以有多次取址
* 超长指令字
    * 由编译程序挖掘出指令潜在的并行性
    * 将多条能并行操作的指令组合成为一条
    * 具有多个操作码字段的超长指令字（可达几百位）
    * 显然编写起来困难，难于水平型指令，水平型指令难于垂直型指令。
###### 五段式指令流水线
* 统一机器周期
    * 锁存器机制（蓝色框内为锁存器）
        * 在每个机器之后，即IF,ID,EX,M,WB之后都设置一个寄存器叫做锁存器，这个锁存器用于缓存上个周期的数据
            * 在IF尾的锁存器记录PC中的内容，若存在数据相关，则锁存器一直保持这个内容在锁存中。这也是时序图中为什么后一指令的IF要严格在前一指令的ID开始的时候，如果不这样，锁存器中的内容会被覆盖，引起前一条指令的崩溃
* 周期
    * IF（instruction fetch）
        *  根据PC从指令cache去指令到IF段的锁存器中
    * ID(instruction denode)
        * 取出操作数到ID段锁存器
    * EX(execute)
    * M(memory)
    * WB(write back)
* RISC中两个可以访问主存的指令
    * LOAD指令（Rd为目的寄存器（destination））RS为起始寄存器（register source）
        * LOAD RD,996(RS)
            * (996+(RS))_>RD
                * 意思就是以996这个地址作为开始的数组或者说顺序表，偏移了（RS）个单位地址所指向的内容
        * 这个指令也要经过运算器
        * LOAD RD，MEN
            * （men）-》rd
    * STORE指令(把RS中的内容写到996+偏移量所指的那个内存块)
        * STORE Rs,996(Rd)
            * Rs->(996+(Rd))
        * STORE Rs,mem
            * Rs->(mem’)
* 条件转移指令
    * beq Rs,#偏移量
        * if（Rs）==(Rt)
            * (PC)+指令字长+（偏移量*指令字长）—》pc
        * else
            * （pc）+指令字长——》PC
    * Bne Rs rt.#偏移量
        * 把beq中的==这个条件改为！=就可以了
* 无条件转移指令
    * jmp #偏移量
        * （pc）+指令字长+（偏移量*指令字长）-》pc
## 存储系统
### 存储器的分类
#### 作用层次
##### 主存（主机中）
##### CACHE CPU中
##### 辅存 主机之外
#### 存取方式
##### 随机存储器（ram）（断电后不可存储数据）
###### 动态随机存储（dram）
###### 静态随机存储（sram）
##### 串行访问存储器
###### 顺序存取存储器（磁带）
###### 直接存取存储器（磁盘）
### 存储器的层次化结构
#### cache命中率计算
##### 访问CACHE次数/访问主存次数
#### 含CAHCE的存储系统的平均访问时间
##### cache命中率*CACHE存取周期+（1-cache命中率）*主存存取周期，通常CACHE的周期要短得多
### 半导体随机存取存储器（ROM和RAM都是支持随机存取 ）
#### sram
##### 集成度低，功耗高，速度快，不需要刷新
###### 用于CACHE等高速低容量设备
#### dram
##### 广泛用于主存中
##### 集成度高，功耗低，价格便宜
##### 需要刷新（用电荷存储信息）
###### 集中刷新
* 存在一个长时间的死区
    * 在2ms（由电荷的性质决定）内需要根据行数的不同进行刷新，刷新时间通常为行数*存取周期
###### 异步刷新
* 把死时间分散到各个存取周期之后
    * 在2ms根据行数，由2ms/行数得出刷新周期，即每隔这个时间就刷新一次。最后总体的死时间占比是与集中刷新相同的，但是不会出现一整段死时间
###### 分散刷新
* 每次以行为单位存取后都刷新一次，效率极低，死时间率为50%，一行的刷新时间和存取周期时间相同
###### 不难看出，刷新一般都以行为单位，如果设计的目的是为了减少刷新时间，应当使行尽可能少
#### 只读存储器（rom）（断电后还可以存储数据）
##### （但是不一定真的只能读入而不能写，现代中由一些只读存储器可以通过电擦除的方式进行写入，但是写入速度比读出速度慢的多）
##### EPROM（可擦除可编程只读存储器）
###### 1.可读也可写的只读存储器
###### 2.断电后可以保存信息（与RAM的本质区别）
###### 3.写入的速度慢且次数有限
###### 4.不可以代替RAM作为主存，也不可以作为计算机外部存储器
##### 闪存存储器（U盘）
###### 1.断电保存信息
###### 2.支持热插拔
###### 3.写入和读出的速度都很快
###### 4.可以作为计算机外部存储器，但不可以作为主存
##### 固态硬盘（sata）
###### 1.速度快，价格高
###### 2.有闪存存储器的所有与电
###### 3.控制单元和存储芯片由FLASH组成
#### 引脚数目的计算
##### 1.地址线：按照索引地址最大值的位数
###### 一定要注意，DRAM默认采用地址复用技术，即地址引脚数目为正常的一半，这个一半是一个理想值
###### 实际上这个地址复用是根据内存的存储阵列排列得出的，引脚数为max（log2(行数)，log2（列数））
###### 因此，对于DRAM，如果对于定容的情况，想要尽可能的减少地址引脚的数目，应当让存储阵列的行数列数尽可能相等
##### 2.数据引脚：根据传送数据的位数来定，如果传送的为8位，则应有8个引脚
##### 3.综上，一个4m*8位的DRAM芯片的地址引脚和数据引脚总数为22/2+8=19
### 子主题 7
#### 链接原理
##### 1.主存与CPU通过数据总线，地址总线，控制总线与CPU链接
##### 2.数据总线的位数与工作频率的乘积正比于数据传输率
##### 3.地址总线的位数决定了可寻址的最大内存空间（内存单元或者内存块总数）
##### 4.控制总线（读写）指出总线周期的类型和本次输入输出操作完成的时刻
#### 主存容量上的扩展
##### 位扩展
###### 用8张芯片，把8K*8位，拓展为8K*64位
###### 地址总线数目：与单片芯片的数目相同，若为8K*8，则为13位
###### 数据总线：由多少张芯片组成内存组就需要多少根数据总线，每根数据总线的宽度由内存芯片决定
###### 片选信号要链接到所有芯片，在某一时刻需呀链接到所有的芯片，逻辑上同一串数据可能在好几个不同的芯片上存着
##### 字扩展
###### 用8张芯片，把8k*8位，拓展为64*8位
###### 1.需要增加2/4译码器，即片选信号产生器
###### 2.在同一个时候只需要选中一个芯片即可，因此需要2/4译码器来完成这个片选的工作
###### 3.以8*8位，两张做自扩展举例，扩展为16*8位，地址位为4，第一位为片选信息
* 第一片地址序列：0000-0111
* 第二片地址序列：1000-1111
* 即在地址首位还要加几位片选信息
##### 字位同时扩展
###### 1.加入译码器
###### 2.一个译码器选中一组位扩展的芯片
###### 3.可以理解为，字扩展需要增加地址引脚，位扩展需要增加数据引脚
* 1.若字扩展选择线选法，即用01111，1011来选择01两个芯片，会导致内存分配不连续且利用率低，片选法则解决了这个问题，但是两者实际上都增加了地址引脚的数目，但是片选内部寻址单元更多
* 2.位扩展则增加了数据线的引脚数目，提高了存取的并发度，但是位扩展需要增加大量的数据总线
* 3.采用字位同时扩展可以更好的扩容，又不用增加过多引脚和总线宽度
### 双端口RAM和多模块RAM（速度 ），（因为RAM的恢复时间很长）
#### 双端口
##### 含义：一个RAM同时有左右两个独立的端口，分别具有两组独立的地址线，数据线和读写控制线
##### 缺点：当两个端口同时访问一个内存单元，并且其中一个有写操作时，会发生错误，并且占用更多资源
###### 同时写：写错误
###### 一个写一个读：读错误
###### 需要更多的cache资源
##### 解决办法：设置忙信号，类似总线中的解决办法，由判断逻辑决定暂时关闭一个端口
##### 适用范围：优化多核心CPU访问一根内存条的数据
#### 为了提高访问速度，采用多模块
##### 单体多字存储器
###### 特点：只有一个存储体，每个存储单元存储M个字，总线宽度也位M,一次并行读出M个字，地址必须顺序排列
###### 缺点：内存必须联系存放
###### 把多个低地址交叉存储器合并为一整行，灵活性更差，比如指令分布在两行中，会读取出一些冗余数据
##### 多体低位交叉存储器
###### 提出理念：根据存储分级系统，CPU的速度比主存快的多，如果采用低位交叉编织，可以并行的从主存中读取出多条指令，提高运行速度
###### 实现方式：采用低位表示体号，高位表示体内地址
###### 流水线方式：读取N个存储单元，耗时为T+（n-1）*r。其中T为存取周期，r为存取时间，T=r+恢复时间
* 故最好存储体数目=T/r想上取整
##### 高位交叉编址
###### 1.高位表示体号，低位表示体内地址
###### 2.模块内的地址是连续的，存取方式仍然为串行，不能几个内存条一起工作，无法提高存储器的吞吐率
###### 3.实际效果就是字扩展，单纯的扩容，没有提速的效果
#### 如何组装一台双通道RAM
##### 1.双通道：低位交叉编址的应用
##### 2.内存条配置可以最好采用相同主频和容量的内存条组成双通道
### Cache
#### 局部性原理
##### 时间局部性
###### 底层原理：页面置换算法，无论采取何种页面置换算法，近期被使用的数据都会在页面中，因此现在访问的数据将来还要访问，发生缺页的概率小，称作时间局部性好
##### 空间局部性
###### 底层原理：在运行过程中，在内存中把数据调进CACHE采用行优先的模式，按行便利访问完一个CACHE块中的数据仅发生初始调入一次缺页，而按列调入，每几个数据就会发生一次缺页，而缺页中断处理非常耗费时间
#### 基本工作原理
##### CPU与CAHCE之间的数据交换以字为单位，cahce与主存之间的交换以CACHE块为单位
##### 在硬件层面，cache由集成度低且不用刷新低SRAM组成，速度上快于主存。
#### 指令cache和数据cache
##### 把cache分成指令cahce和数据cache，可以有效的减少资源访问冲突，减少结构性相关。
#### 与主存的映射方式（重点在于分析地址结构，以及和虚拟存储器结合）
##### 直接映射（线性映射）
###### 特点：主存的块号与cache的块号有直接的映射函数，类似于散列查找
* 缺点：直接映射是冲突概率最高，空间利用率最低的映射方法
* 优点：实现简单
###### 2.直接映射遇到冲突直接替换，不需要页面置换算法
###### 3.地址结构为 标记 cache行号 块内地址
* 主存容量是cache的多少倍则log2【倍数】为标记位的位数，通常还要在更高的地址为放一个一位的是否访问的有效位，若为写回法，还要置一个脏位
* 低位地址为块内地址，一个块如果为8*32位，则需要8位块内地址
* 中间部分则为在cache中的块号，总位数可由log2【cache总容量/cache块容量】得出
###### 4.在应用中，选择主存的第N位，映射到对应CACHE行中，比较高位中的标记信息，若想等且有效位为1，则命中cache，其余情况把这个内存块中的内容调入cache中
##### 全相联映射（随机映射）
###### 特点：主存中的每一块都可以装入cache中的任何位置，每行的标记用于指出该行取自主存的哪一块，在进行命中判断时需要与每一块进行比较
* 优点：空间利用率高，冲突率低
* 缺点：比较标记时间开销大，实现成本高，通常需要昂贵的项链存储器
###### 地址结构为：标记 块内地址
##### 组相联映射（组间线性，组内随机）
###### 特点：把CACHE分为大小相同的组，主存的数据块可以装入组内的任何一个位置，组内随机，组间线性
* 优点：当组取的合适时，可以使实现成本接近直接映射而冲突率接近于全相联
* 当组为1时，组相联等于全相联，当组为CAHCE行总数时组相联等于直接映射
###### 地址结构 标记 组号 块内地址
###### 在以内存单元为单位进行cache映射时，也要按组的大小吧内存单元划分成组号的形式，再映射到cache中
* 例如二路组相联映射，0，4，8，2号内存序号单元分别对应0 1 0 0组
#### cache替换算法（用于全相联和组相联）
##### 随机替换算法
##### 先进先出算法
##### 最近最少使用算法
###### 需要在标记矩阵中加一位替换控制位
##### 最不经常使用算法
##### 未依据局部性原理
#### 写策略
##### CACHE写命中
###### 全写法（写直通法）
###### 写回法
* 需要在标记矩阵中加一位脏位
* 这个脏位在页表机制中可用于改进后的CLOCK页面替换算法
##### CACHE写不命中
###### 写分配法
###### 非写分配法
##### 非写分配法与全写法搭配
###### 全写法是每次cache被修改都需要写回主存，适用于安全性要求高的应用领域，比如银行系统
##### 写分配法与写回法搭配
###### 这种搭配适用于大量存储器写操作的数据访问密集型应用，因为这种情况下在用写回法可以大大减少访存次数
### 虚拟存储器
#### 定义：将主存和辅存的空间统一编址，由于程序的局部性原理，可以轮换着将磁盘中的内容调入主存中，从逻辑上扩充内存
#### 硬件实现：PAGE和页表存放在主存中，一般由SRAM实现，而TLB（translation buffer）由更高速的SRAM实现
#### 与cache机制的区别与联系
##### 区别
###### cache主要为了解决系统速度，虚拟内存是为了扩充主存容量
###### cache由硬件实现，对所有程序猿透明，而虚拟存储（页表映射）机制由OS和硬件共同实现，对系统程序员不透明而对应用程序员透明
###### 缺页的处理时间远大于cache缺失的处理时间
* 缺页
    * 由CPU检测到的一种异常
    * 由OS提供的缺页处理程序完成
    * 根据页故障地址从外存读入缺失的页面
    * 缺页处理完成后返回到缺页的那条指令继续往下执行（由中断隐指令保存PC和PSW中的内容）
* cache缺失处理过程
    * 程序计数器恢复当前指令的值
    * 对主存进行读操作
    * 将读入的指令写入cache中，更改有效位和标记位
    * 重新执行当前指令
###### CPU有与cache和memory的直接通路，而和DISK则没有这样的性质，因此如果cache未命中，主存中数据写入cache和传输到cpu两者可以并发执行，而缺页则不行。
##### 联系
###### 都是为了提高系统性能，两者都有速度，价格的阶梯
###### cache的块大小一般为64b,而虚存的页大小为4kb
###### 都有地址的映射，替换，更新策略等问题
###### 都依据程序的局部性原理“对程序的访问是不均匀的”，把经常访问到的程序段放在更高速的硬件中
#### 与CACHE的联合考点
##### 由页表大小通常远大于cache块的大小，因此在既有页表机制又有cache机制的计算机中，经常不需要知道该页准确的物理地址，也可以根据低12位得出该页在cache中的地址
##### TLB不一定全都采用全相联映射，往年408考过用二路组相联映射，则此时的页表页框映射需要把（虚页号，页内偏移量）改为（标记，组号，页内偏移量），再在PAGE中进行寻址
## 数据的运算和表示
### PSW的几种比较状态
#### 无符号数的比较
##### 大于
###### CF=0,ZF=0
* ZF（zero flag）：零标志
* CF（carry flow）：进位标志
##### 等于
###### CF=0 ZF=1
##### 小于
###### CF=1,ZF=0
#### 有符号数的比较
##### 大于
###### SF=0 OF=0 ZF=0
* ZF：零标志
* SF（sign flag）：符号位
* OF（overflow flag）：溢出标志
##### 等于
###### SF=0,OF=0,ZF=1
##### 小于
###### SF=1,OF=0,ZF=0
#### 标志的名字和英文对应
##### CF
###### 借位标志，用于判断无符号数相减有没有向高位借数字，如果有发生借数字且差不为0，则A<B
##### ZF
###### 零标志，用于在其他标志都没被改变的时候，判断两个机器数是否相等
###### Zero flag
##### OF
###### 溢出标志，所有有符号数字的有效判断溢出都为0，高位溢出会直接发生内中断，低位溢出则为精确度不够
###### Overflow flag
##### SF
###### 符号标志，用于判断有符号数字相减符号位是否发生改变，显然，这是用于判断A<B的
###### Signal flag
### 数制与编码
#### 目前计算机广泛采用二进制编码而不采用十进制编码的原因是因为运算器高低电平的物理特性决定的
##### 任何一个十进制整数都可以精准的转化成为一个二进制数，而例如0.3这样的小数不一定可以转化成二进制数
###### 如果运算器位数不够，导致数据转化上溢，则会产生内中断
###### 而浮点数转换下溢不会出现中断的情况，仅仅只是因为精确度不够。
###### 即最低有效位在没办法的时候就被忽略了，而最高有效位不可以
* 大端存储：最高有效位放在低地址中
* 小端存储：最高有效位放在高地址中
##### 十进制整数转换为二进制整数：除数取余法
###### 原理：和地址分析中的偏移量分析原理差不多，除以二取余表示低地址需要一个1来表示，因此最终排列顺序从低到高
##### 十进制小数转换为二进制数：乘积取整法
###### 原理：由小数转为二进制，乘以二取出1，表示原来那个数就是含有0.5的，标记1，再乘再取，就表示0.25.逐渐递推则可得到相应结论
#### 真值和机器数
##### BCD码：用四位二进制数表示一位十进制数
###### 8421码：四位数按照权重分配，其实就是二进制表示法，因此是最常用的方法
###### 余3码：无权码，在8421码的基础上加上（0011）而成，因此称为余3码（这不是傻逼吗）
###### 2421码：也是一种有权编码，但是特点是大于5的数字最高位为1，小于5的数字第一位数为0.比如5的2421码为1011而非0101，这样有助于计算机区分小于5和大于5的数字
##### ASCALL码
###### ASCALL码共用128个，由7位二进制数来表示，但是在机器中仍然以一个字节保存，最高有效位一直为0
#### 校验码
##### 码距：不同编码之间的高低电平差异数目，1100和1101的码距为1，1001和0010的码距为3
###### 对于码距大于等于2的数据校验码，就开始具有检错的能力，码距越大，检错纠错的能力就越强
##### 奇偶校验码
###### 分类
* 奇校验码
    * 加上校验码有奇数个1
* 偶校验码
    * 偶数个1
###### 特点：码距为2，可以检测出一位（或奇数位错误），但没有纠错和检验偶数位错误的能力
###### 大致过程：发送方与接收方约定奇偶校验方式，根据不同的校验方式在数据首位补足校验码
* 如信息为10，奇校验码010，偶校验码110，若接收方收到的奇校验码为110，则出错，若为111，则为差错未被检验
##### 海明码（具有纠错功能）
###### 基本思想
* 将信息位分为多个分组进行偶校验，设置多个冗余信息位作为校验位，可以标记出出错位置
* 由多个检验位检验一个数据位，当然一个检验位也被用于多个数据位的检验，其检验分布由其排列决定，由检验位分布在1，2，4，8等位置上，其余位置的数据码由检验位位置加和表示，例如3号位置，3=1+2，由检验码1和2一起检验这个数
###### 求解步骤
* 确定检验位数(n个信息位，k个校验位)
    * 2^k》=n+k+1
* 确定校验位分布
    * p1,p2,p3..分别在1，2，4，8，16.。
    * 空出来的其他位置依次填入信息位
* 求检验位
    * 将信息位的位置序号用K位二进制数表示出来
    * 检验位Pi与位置序号第i位为1的信息位归为同一组，进行偶校验
* 纠错
    * 对p1,p2,p3...所属各分组进行异或运算（相当于分组偶校验），求的S1，Ｓ2，Ｓ3
    * s3 s2 s1=000说明无错误
    * s3 s2 s1不等于000，则其值反映出错位置
###### 补充
* 海明码具有一位纠错，两位检错能力
* 为了区分一位错和两位错，可以增添一个全校验位对整体进行偶校验
* 注意：位置编号可以从小到大排列，但是处理方法是雷同的
##### 循环冗余检验码（CRC）
###### 基本思想：在K位的信息码后再拼接R位的校验码，整个编码的长度为N位，因此这种编码也被称为（N，Ｋ）编码
###### 构造
* 由生成多项式确定除数，若生成多项式最高次为R，则除数有R+1位
* K个信息位+R个零（低位补0）作为被除数
* 被除数，除数进行“模二除”，得R位余数
* K个信息位+R位余数=CRC码
###### 校验 
* 收到K+R位数据，与生成多项式模二除，计算R位余数
* 余数位0，说明无错误
* 余数非0，说明出错
###### 检错，纠错能力
* 可检测出奇书个错误
* 可检测出所有双比特错误
* 可检测出所有小于等于校验位长度的连续错误
* 若选择合适的生成多项式，且2^R>=K+R+1,则可以纠正单比特错误
### 定点数的表示与运算
#### 表示方法
##### 原码
###### 表示范围
###### 有正0和负0
###### 由于原码和反码均采用正负0，因此其整数和小数范围均为-（2^n-1）~(2^n-1)
##### 反码
###### 真值0有两种表示形态
##### 补码
###### 真值0也只有一种表示方式
##### 移码
###### 用来表示浮点数的阶码，他只能表示整数
* 移码中0的表示唯一
* 一个真值的移码和补码仅差一个符号位
* 移码全0时，对应最小值-2^n，全一时对应2^-1
* 移码保持了数据原有的大小顺序，移码大真值就大
##### 转换关系
###### 这里插入P39页图2.6
##### 不同码的作用
###### 加减运算
* 原码：因为原码直接做减法会出现错误，必须要把符号位考虑在内，而计算机的设计逻辑减法器设计非常复杂
* 补码：由于补码正数和负数的不同表示方法，因此减法只需要将正数+（负数），两个补码直接相加即可
    * 采用补码可以把减法转换为加法，减少硬件设计成本，现在计算机中机器数的表示基本都是采用补码的方式
*  移码：由于移码的编码特点，其机器数大小与真值大小相同，因此采用移码可以很方便的比较不同数之间的大小关系
#### 移位运算（SHR SHL）
##### 算数移位
###### 定义：移位对象为有符号数，二进制数左移相当于真值*2，右移为/2
###### 由于不同码字的编码规则，填补空缺也有不同的规则
* 正数
    * 均添0
* 负数
    * 原码
        * 添0
    * 补码
        * 左移添0
        * 右移添1
        * 负数补码中，最右边的1及其右边同原码，最右边的1的左边同反码，因此右移时，高位同反码，补1.左移最低有效位同原码，补0
        * 举例说明码字分段关系
            * 加上王道PPT的图
    * 反码
        * 添1
        * 因为原码的0相当于反码的1
##### 逻辑移位
###### 定义：无论左移还是右移，都补0.移丢位直接舍弃
###### 用途：数组平移，即所有码字都不带权时
##### 循环移位
###### 定义：把左移或者右移后的数放回另一段
###### 作用：适合数据的低字节数据和高字节数据互换，例如大小端存储
#### 原码定点数的加减运算
##### 加法
###### 同号相加
* 数值部分=A，B的数值部分相加
* 符号位不变
###### 异号相加
* 数值部分=A.B中绝对值更大的减绝对值更小的
* 符号位与绝对值更大的那个数相同
##### 减法
###### 将减数取负，转变为加法
#### 补码定点数的加减运算
##### 总是要转变为加法，其中正数的减法需要把正数转变为负数，有两种方法
###### 符号位改变，数值位取反加一
###### 符号位改变，从补码右边往左边数第一个1，包括这个1在内的所有右边的数与原码相同，这个1左边的数与反码相同，因此把左边的数取反即可
#### 定点数的乘除运算
##### 乘法
###### 乘法运算的实现思想
* 乘法运算由累加和右移操作实现。根据机器数的不同分为原码一位乘法和补码一位乘法，原码一位乘法的计算比补码简单
###### 原码的一位乘法
* 符号不参与运算，数值位的绝对值进行运算得到最终的数值，符号位由AB两个数字原本的符号位进行异或运算得到
* 整个计算过程中累加N次，以Ａ＊Ｂ为例，这个N为B的位数。若最低位为1.则累加器加上被乘数数值，若为0，则加上0。然后进行（逻辑右移！！！）很重要
* 由于符号位不参与运算，因此整体右移N次，累加N次
###### 补码的一位乘法
* 符号位参与运算，运算的数均以补码表示
* 由于乘数要添加一位符号位，因此被乘数和ACCZ中的高位部分积也采用双符号位统一寄存器的位数
* 每次累加有三种情况，且由于补码的乘法运算符号位也参与运算，因此需要累加N+1次，这个N也位乘数的位数
    * 辅助位-最低位=1. ACC+X补
    * =0.ACC+0
    * =-1 ACC+[-X补]
* 整体过程虽然累加N+1次，但是右移仅右移N次，并且由于符号位参与运算，这时的右移为算数右移
    * 当ACC中的数为正数时，高位添0
    * 当ACC中的数为负数时，高位添1
###### 原码和补码乘法运算的差别
* 补码符号位参与运算，原码符号位不参与运算
* 最终结果的符号位：原码通过异或运算得到，补码通过计算得到
* 累加次数原码为N次，补码为N+1次
* 右移次数都为N次，但是原码采用逻辑右移，补码采用算数右移
* 每次累加的乘数，原码根据乘数最低位直接得出单次累加结果，补码根据辅助位减去最低位的值乘被乘数得出本次累加结果
    * 原码只有0 1两种单词乘数
    * 补码有 -1 0 1三种乘数
##### 除法
###### 原码除法运算
* 恢复余数法
    * 左移n次，上商n+1次
    * 余数为负时商0，并加上除数，再左移，再减去余数
        * 表面上看是因为余数小于除数，需要恢复原来的余数，因此先加上刚刚被减去的除数，在进行下一步运算，即先左移再减去除数
        * 究其本质，是（a+b)*2-b,得到2*a+b,不恢复余数法就是通过这种方式对原码的除法运算速度进行优化的
* 不恢复余数法
    * 根据余数的符号位不同采取不同的操作
        * 余数为负时商0，在进行左移，再加除数的绝对值
        * 余数为正时商1，进行左移然后减去除数的绝对值
###### 补码除法运算（加减交替法）
* 总的原则是根据被除数或者当前余数和除数补码的符号来判定操作
    * 异号
        * 起始位置：若异号则+y补
        * 部分余数：若异号则商记为0，左移后加上y补
    * 同号
        * 起始位置：若同号则-y补
        * 部分余数：若同号则商记为1，左移后再减去y补
* 商的末尾不再根据符号进行反异或运算，而是直接纪委1，这样误差范围就很小，但是可以省去一些时间
###### 除法运算
* 补码运算
    * 符号位参与运算
    * 加减次数为N+1
    * 移位N次
    * 商末位恒为1
* 原码运算
    * 符号位不参与运算
    * 加减次数位N+1或N+2
        * 若余数为负，则需要恢复余数，即再加上除数，加减次数为N+2
        *  若余数为正，则直接作为余数，总的加减次数为N+1
    * 移位N次，方向向左
#### 溢出概念和判别方法
##### 无论哪种判别方法，其内核就是：正+正=负数（上溢），负+负=正数（下溢）
###### 
##### 判别方法
###### 一位符号位
###### 两位符号位
* 
    * 
###### 一位符号位和一位进位位
* 与两位符号位差不多，只要符号位和进位位数值相同，则不发生溢出。符号位与进位位数值不同，则发生溢出
#### 符号扩展
##### 定点小数的扩展
###### 正数
* 添0
###### 负数
* 原码补码添0，反码添1
###### 在原符号位和数值位后面增添新位，此时添加的位数肯定都在第一个1右边，编码规则同原码
##### 定点整数的扩展
###### 正数
* 高位添0
###### 负数
* 原码添0，补码，反码添1，和右移规则差不多
###### 在原符号位和数值位中间添加新位，此时增添新位肯定都在从右往左数第一个1左边，编码规则同反码
#### C语言中整数类型及类型转换
##### 有符号数和无符号数
###### 类型转换时机器数不变，根据不同类型的数据表示的内容进行转换即可
###### 需要注意unsigned short usi=65535，在有赋值语句short si=usi；之后 usi的真值为-1，因为65535无符号数的机器数为FFFF H，转换为有符号数之后以补码表示，转换成真值即为-1
#### 大端小端
##### 若一个机器数表示为11 22 33 44H
###### 大端方式： 11 22 33 44H （地址递增）
###### 小端方式 44 33 22 11H（地址递增）
#### 边界对齐
##### 即按字，字节，半字寻址
##### 若一个字由4个字节组成，那么默认一个字采用用四个存储块，且边界对齐，那么就只用一次访存
##### 边界对齐是一种空间换时间的策略，可能在存储阵列中会存不满对齐的单元，但是采用对齐策略，取出一个int，short只需要一次访存即可
### 浮点数的表示与运算
#### 浮点数的表示
##### 浮点数的作用和基本原理
###### 表示方法
* 尾数给出具体数值，阶码表明小数点前移，后移多少位
* 阶码通常为补码，移码表示的是定点整数
* 尾数通常用补码，原码表示的定点小数
* 真值=基数^阶码*尾数
    * 不难看出数的大小由阶码规定
    * 浮点数的精确度由尾数规定
##### 浮点数规格化
###### 规格化的主要目的：增加数据的表示精度
###### 尾数的最高数值位必须是一个有效值（类比十进制科学计数法，数值部分最高位非0）
###### 左归，数值位最高位无效时，通过使尾数算数左移，阶码-1的方法处理，直到尾数最高数值位有效时停止
###### 右归：采用双符号位表示尾数，则当运算后尾数“假溢出”时，可以通过尾数右移，阶码+1的方法处理
###### 原码表示的尾数规格化：尾数的最高位数值必须为1
###### 补码表示的尾数规格化：尾数最高数值位必须和尾数符号相反
##### 浮点数的表示范围（简单了解）
###### 表示范围：即数值大小和表示精度都有一个范围，超过了绝对值最大值则称为正上溢，低于绝对值最小值则称为正下溢。
* 正上溢则溢出中断
* 下溢则作为机器0不做处理
###### 注意定点书和浮点数的溢出表述差异
* 浮点数
    * 上溢分为正上溢和负上溢出，表示数据太大位数不够表示
    * 下溢就是由于浮点数的精度问题，无法表示更加精确的小数
* 定点数（阶码）
    * 上溢就是大于最大值
    * 下溢就是小于最小值
#### IEEE 754标准
##### 阶码全0和全1的特殊用途
###### 阶码E全为0
* 尾数不全为0
    * 非规格化小数：+-（0.x1x2x3.....xn）*2^(-126)
* 尾数全为0
    * 表示 +-0
###### 阶码E全为1
* 尾数全为0
    * 无穷大
* 尾数不全为0
    * 非法结果（NAN ）（not a number）
##### 浮点数和真值的转换
###### 用阶码表示小数点相对于尾数移动多少位
#### 浮点数的加减运算
##### 加减运算
###### 对阶
* 小阶向大阶靠齐，尾数算数右移一位，阶码➕1，直到阶码相同为止
* 注：对阶可能会丢失末位精度
###### 尾数加减
* 通常采用双符号位表示尾数，如果尾数加减溢出可以通过阶码补救
###### 规格化
* 左规：尾数最高数值位为无效位时，尾数左移，阶码减1
* 右规：尾数双符号位不同时，尾数右移，阶码+1
###### 舍入
* 尾数的尾数位固定，要丢弃一些尾数位，常用方法有两种。一种是0舍1入，一种是恒置1
* 通过恒置1或者进1的方式，会使浮点数表示的数据大于或者小于真值，通常差的真值为1
###### 判溢出
* 如果阶码超出了固定位数，如果超出了最大范围则判断发生溢出，只有阶码溢出才是真的溢出，尾数溢出可以通过规格化进行补救
* 阶码上溢出
    * 溢出中断
* 下溢出
    * 作机器0处理
##### 强制类型转换
###### 无损
* char-int-long-double
* float-double
###### 有损
* int-float
    * 可能会损失精度（float尾数的数值位有（1）+23位
* float-int
    * 可能会溢出，也可能会损失精度
### 算数逻辑单元
#### 作用，大致原理
#### 电路基础知识
#### 加法器的实现
## 分支主题 8
## 组合逻辑电路
时序逻辑电路
区别
### 组合逻辑电路
时序逻辑电路
#### IO关系
##### 组合逻辑电路是任意时刻的输出仅仅取决于该时刻的输入
#####  时序逻辑电路的输入不仅取决于当前的输入，还取决于电路原来的状态
#### 有无存储（记忆）单元
##### 组合逻辑电路没有存储记忆
##### 时序逻辑电路包含了存储记忆
#### 结构特点
##### 组合逻辑电路只是包含了电路
##### 但是时序逻辑电路包含了组合逻辑电路和存储电路，输出信号必须反馈道组合电路的输入端，与输入信号共同决定组合逻辑的输出
